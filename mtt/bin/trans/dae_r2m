#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: dae_r2m
# Reduce DAE to OCTAVE (DASSL) DAE  
# P.J.Gawthrop 14 June 1991, 12 Jan 1994, April 1994, Jan 95, Aug 97.
# Copyright (c) P.J.Gawthrop 1991, 1994, 1995, 1996

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
## Revision 1.7  1998/05/13 16:43:03  peterg
## Now uses matlab_matrix to write the matrices
## Various bug fixes
## New global generation method
##
# Revision 1.6  1997/08/28  14:07:16  peterg
# Changed MTTDx to MTTDeriv
#
# Revision 1.5  1996/08/24  14:27:29  peter
# Global parameters.
#
## Revision 1.4  1996/08/18 20:02:21  peter
## Include zero outputs.
##
## Revision 1.3  1996/08/16 13:10:53  peter
## Fixed bug Ny changed to Nx in redidual loop.
##
## Revision 1.2  1996/08/16 08:57:34  peter
## Reads $1_input.
##
## Revision 1.1  1996/08/15 16:46:06  peter
## Initial revision
##
###############################################################


# WARNING this is experimental!!
# It asumes that the output y is NOT dependent on derivatives of
#  z or u.


#Inform user
echo Creating $1_dae.m
echo Creating $1_daeo.m


# Remove the old log file
rm -f dae_r2m.log

# Remove temp. files
rm -f $1_dae.m?
rm -f $1_daeo.m?

# Use reduce to accomplish the transformation
$SYMBOLIC >dae_r2m.log << EOF

%Read the reduce definitions file
in "$1_def.r";

%Read the reduce  DAE   file
in "$1_dae.r";

% Matrix output function
in"$MTTPATH/trans/matlab_matrix.r";

%Set up the number of argument variables to zero in case the user has forgotten
MTTNVar := 0;

%Read the parameter file
%%in "$1_sympar.r";


%% ON NERO;        % Suppress zero elements

%Define the common part of the functions.

PROCEDURE common;
BEGIN

  write "% Read in the input";
  write "u = $1_input(x,t)";

 % write "% Read in the arguments";
 % write "$1_args";
  
  write "% Set up the State variables";
  FOR i := 1:MTTNx DO
  BEGIN
    write "mttx", i, " = mttx(", i, ");";
  END;

  write "% Set up the non-state variables";
  FOR i := 1:MTTNz DO
  BEGIN
    write "mttz", i, " = mttx(", MTTNx+ i, ");";
  END;
  write "% Set up the non-state derivatives";
  FOR i := 1:MTTNz DO
  BEGIN
    write "mttdz", i, " = mttx(", MTTNx+MTTNz+ i, ");";
  END;

   write "% Set up the internal inputs";
  FOR i := 1:MTTNyz DO
  BEGIN
    write "mttui", i, " = mttx(", MTTNx+2*MTTNz+i, ");";
  END;
  
  write "% Set up the Input variables";
  IF MTTNu>0 THEN
  FOR i := 1:MTTNu DO
  BEGIN
    write "mttu", i, " = u(", i, ");";
  END;
END;
  
% Firstly do the residual = f(dx,x,t) function.

% MTTGx and u are the derivatives of z wrt x and u respectively

% Find MTTGx;
if MTTNz>0 THEN
BEGIN
matrix MTTGx(MTTNz,MTTNx);
FOR j := 1:MTTNx DO
  BEGIN
  xj := MTTX(j,1);
  FOR i := 1:MTTNz DO
    MTTGx(i,j) := df(MTTZ(i,1), xj, 1);
  END;

% Find MTTGu;
matrix MTTGu(MTTNz,MTTNu);
FOR j := 1:MTTNu DO
  BEGIN
  uj := MTTu(j,1);
  FOR i := 1:MTTNz DO
    MTTGu(i,j) := df(MTTZ(i,1), uj, 1);
  END;
END;

IF MTTNz=0 THEN
BEGIN
  MTTGx := 0;
  MTTGu := 0;
  MTTz := 0;
END;

OUT "$1_dae.m1";
write "function residual = $1_dae(mttx,deriv0,t);";
write "% residuals = $1_dae(dx,x,t);";
write "%DAE in DASSL $1;;";
write "%File $1_dae.m;;";
write "%Generated by MTT;;";


common();
SHUT "$1_dae.m1";

GENTRANOUT "$1_dae.m3";
write "% State derivative";
IF MTTNX>0 THEN
BEGIN
  MTT_Matrix := MTTdX$ 
  MTT_Matrix_name := "deriv"$
  MTT_Matrix_n := MTTNx$
  MTT_Matrix_m := 1$
  matlab_Matrix()$
  GENTRAN deriv := mtt_matrix$
END;

IF MTTNYz>0 THEN
BEGIN
  MTT_Matrix := MTTYz$ 
  MTT_Matrix_name := "MTTYz"$
  MTT_Matrix_n := MTTNYz$
  MTT_Matrix_m := 1$
  matlab_Matrix()$
  GENTRAN MTTYz := mtt_matrix$
END;

if MTTNz>0 THEN
BEGIN
  MTT_Matrix := MTTz$ 
  MTT_Matrix_name := "MTTz"$
  MTT_Matrix_n := MTTNz$
  MTT_Matrix_m := 1$
  matlab_Matrix()$
  GENTRAN MTTz := mtt_matrix$

  MTT_Matrix := MTTGu$ 
  MTT_Matrix_name := "MTTGu"$
  MTT_Matrix_n := MTTNz$
  MTT_Matrix_m := 1$
  matlab_Matrix()$
  GENTRAN MTTGu := mtt_matrix$

  MTT_Matrix := MTTGu$ 
  MTT_Matrix_name := "MTTGx"$
  MTT_Matrix_n := MTTNz$
  MTT_Matrix_m := 1$
  matlab_Matrix()$
  GENTRAN MTTGx := mtt_matrix$

END;


SHUT "$1_dae.m3";

OUT "$1_dae.m4";
%  write "% Set up the non-state derivatives";
%  FOR i := 1:MTTNz DO
%    write "mttdz", i, " = mttderiv0(", MTTNx+ i, ");";
%  END;

write "j = 0;";

%Residual has 3 parts as follows:
%Part 1: dx/dt - dx_0/dt
if MTTNx>0 THEN
BEGIN
  write "for i=1:", MTTNx, ";;";
  write "  j = j+1";
  write "  residual(j) = deriv(i)-deriv0(j);";
  write "end;";
END;

%Part 2: dz/dt - dz_0/dt
IF MTTNz>0 THEN
BEGIN
  if MTTNx>0 THEN
    write "mttdzx = mttgx*mttdx"
  ELSE
    write "mttdzx = zeros(", MTTNz, ",1);";


  if MTTNu>0 THEN
    write "mttdzu = mttgu*mttdu"
  ELSE
    write "mttdzu = zeros(", MTTNz, ",1);";

  write "mttdz = mttdzx + mttdzu";

  write "for i=1:", MTTNz, ";;";
  write "  j = j+1";
  write "  residual(j) = mttdz(i)-mttderiv0(j);";
  write "end;";
END;

%Part 3: v=0 (the algebraic bits)
IF MTTNyz>0 THEN
BEGIN  
  write "for i=1:", MTTNyz, ";;";
  write "  j = j+1";
  write "  residual(j) = mttyz(i)";
  write "end;";
END;

SHUT "$1_dae.m4";


% Now do the y = g(x,t) function.
OUT "$1_daeo.m1";
  
write "function mtty = $1_daeo(mttx,t);";
write "% mtty = $1_daeo(mttx,t);";
write "%DAE in Simulab form for system $1;;";
write "%File $1_daeo.m;;";
write "%Generated by MTT;;";

SHUT "$1_daeo.m1";

OUT "$1_daeo.m3";
common();


%Fortran switches - one line expressions
OFF echo;
ON fort$
cardno!* := 1$
fortwidth!* := 500$
OFF period$

MTTy := MTTy;

SHUT "$1_daeo.m3";

EOF

# Create the globals
sympar2global_txt2m $1> $1_dae.m2
sympar2global_txt2m $1> $1_daeo.m2

# Put together the pieces
cat $1_dae.m?>$1_dae.m
cat $1_daeo.m?>$1_daeo.m







