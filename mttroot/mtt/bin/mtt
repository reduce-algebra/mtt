#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt

# Usage: mtt system_name  representation_name
# E.g.: 
# 	mtt dc mtf
# converts dc to matlab transfer function form.
#
# P.J.Gawthrop Oct 1989, Dec 1989, 1990, 1991, Oct 1993, Dec 1993, Jan 1994, Dec 95
# Copyright (c) P.J.Gawthrop, 1989, 1990, 1991, 1993, 1994, 1995, 1996.

###############################################################
## Version control history
###############################################################
## $Header$
## $Log$
## Revision 1.6  1996/08/11 10:40:56  peter
## Added new numpar stuff.
## Added step response.
##
## Revision 1.5  1996/08/10 14:13:47  peter
## Added impulse and frequency response stuff.
##
## Revision 1.4  1996/08/10 09:19:48  peter
## Put in help, info and warranty stuff.
##
## Revision 1.3  1996/08/09 15:13:13  peter
## Generic viewing of any representation via ps files implemented.
##
## Revision 1.2  1996/08/05 19:50:55  peter
## Put in fig.fig target.
##
## Revision 1.1  1996/08/04 17:29:42  peter
## Initial revision
##
###############################################################
echo
echo 'MTT (Model Transformation Tools) version 2.0'
echo 'This is free software with ABSOLUTELY NO WARRANTY.'
echo 'Type `mtt warranty'\' 'for details.'
echo

if [ "$1" = "" ]; then
  echo 'Usage: mtt info'
  echo '       mtt warranty'
   echo '       mtt system_name representation language'
   echo '       mtt system_name representation language parameters'
  exit
fi

if [ "$1" = "info" ] && [$2 = ""]; then
  info -f $MTTPATH/../doc/mtt.info
  exit
fi

if [ "$1" = "warranty" ] && [$2 = ""]; then
  cat << EOF
Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995,1996 Peter J. Gawthrop
This is free software with ABSOLUTELY NO WARRANTY.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

EOF
  exit
fi

if [ "$1" = "clean" ] && [$2 = ""]; then
  echo 'Removing log, dvi and ps files'
  rm *.log *.dvi *.ps
  exit
fi

# This is the main mtt programme
 
make  -s -f -  $1_$2.$3 << EOF

#Create acausal bond graph figure using xfig 
$1_abg.fig:
	$FIG $1_abg.fig &

#Create empty files (with titles) if not already there
$1_lbl.txt:
	echo Creating $1_lbl.txt
	( \
	echo "%% Label file ($1_lbl.txt)"; \
	echo "%% Each line should be of one of the following forms:"; \
	echo "%	a comment (ie starting with %)"; \
	echo "%	Component-name	CR_name	arg1,arg2,..argn"; \
	echo "%	blank"; \
        )> $1_lbl.txt
$1_cr.r:
	makecr $1
$1_sympar.r:
	echo Creating $1_sympar.r
	( \
	echo "%% Symbolic parameter file ($1_sympar.r)"; \
	echo "%% Change the following line to reflect the number of variables"; \
	echo "MTTNVar := 0;"; \
	echo "IF MTTNVar>0 THEN MATRIX MTTVar(MTTNVar,1);"; \
 	echo "%% Add an assignment statement here for each variable"; \
 	echo "%% For example: MTTVar(1,1) := r"; \
        )> $1_sympar.r
$1_simp.r:
	echo Creating $1_simp.r
	( \
	echo "%% Reduce comands to simplify output ($1_simp.r)"; \
        )> $1_simp.r
$1_numpar.m: $1_sympar.r
	mknumpar $1; matlab_tidy $1_numpar.m; matlab_tidy $1_parconv.m

$1_sspar.r:
	echo Creating $1_sspar.r
	echo "%% Reduce steady-state parameter file ($1_sspar.r)" > $1_sspar.r

#Raw bond graph: fig file to mfile
$1_rbg.m: $1_abg.fig $1_lbl.txt
	rbg_fig2m $1

$1_cmp.m: $1_rbg.m

$1_fig.fig: $1_rbg.m

#Bond graph conversions using matlab
#Raw bond graph to acausal bond graph: mfile
$1_abg.m: $1_rbg.m
	rbg2abg_m $1	

#Causal bond graph: mfile to fig conversion
$1_cbg.fig: $1_cbg.m $1_rbg.m $1_fig.fig
	cbg_m2fig $1

#Causal bond graph: xfig display
#$1_cbg.view: $1_cbg.fig
#	echo "Creating view of $1_cbg"; xfig $1_cbg.fig &


#Acausal bond graph to causal bond graph: mfile
$1_cbg.m: $1_abg.m
	abg2cbg_m $1

#LaTex system summary
$1_sum.tex: $1_abg.pl
	abg2sum_pl2tex $1; latex_tidy $1_sum.tex

#Elementary system equations + definitions
$1_ese.r: $1_cbg.m
	   cbg2ese_m2r $1
 
$1_def.r: $1_ese.r

#Differential-algebraic equations
$1_dae.r:	$1_ese.r $1_cr.r $1_sympar.r
	ese2dae_r $1; tidy $1_dae.r
$1_dae.m: $1_def.r $1_dae.r  $1_sympar.r
	dae_r2m $1; matlab_tidy $1_dae.m
$1_dae.c: $1_def.r $1_dae.r  $1_sympar.r
	dae_r2c $1; c_tidy $1_dae.c
$1_dae.tex:	$1_dae.r $1_simp.r
	dae_r2tex $1; latex_tidy $1_dae.tex

#Constrained-state equations
$1_cse.r: $1_dae.r $1_def.r $1_sympar.r
	dae2cse_r $1; tidy $1_cse.r
$1_cse.m: $1_def.r $1_cse.r $1_sympar.r
	cse_r2m $1; matlab_tidy $1_cse.m
$1_cse.tex: $1_cse.r  $1_sympar.r
	cse_r2tex $1; latex_tidy $1_cse.tex

#Ordinary differential equations
$1_ode.r: $1_cse.r $1_def.r $1_sympar.r
	cse2ode_r $1; tidy $1_ode.r
$1_ode.m: $1_def.r $1_ode.r $1_sympar.r
	ode_r2m $1; matlab_tidy $1_ode.m
$1_ode.tex: $1_ode.r  $1_sympar.r $1_simp.r
	ode_r2tex $1; latex_tidy $1_ode.tex

#Observer functions for GPC
$1_obs.r: $1_ode.r $1_def.r $1_sympar.r
	ode2obs_r $1; tidy $1_obs.r
$1_obs.m: $1_def.r $1_obs.r $1_sympar.r
	obs_r2m $1; matlab_tidy $1_obs.m
$1_obs.tex: $1_obs.r  $1_sympar.r $1_simp.r
	obs_r2tex $1; latex_tidy $1_obs.tex


#Robot-form equations
$1_rfe.r: $1_cse.r $1_csm.r $1_def.r $1_sympar.r
	cse2rfe_r $1; tidy $1_rfe.r
$1_rfe.tex: $1_rfe.r  $1_sympar.r
	rfe_r2tex $1; latex_tidy $1_rfe.tex

#Steady-states
$1_ss.r: $1_def.r $1_sspar.r $1_sympar.r $1_cr.r $1_dae.r
	sspar2ss_r $1; tidy $1_ss.r
$1_ss.m: $1_def.r $1_sympar.r $1_ss.r 
	ss_r2m $1; matlab_tidy $1_ss.m
$1_ss.tex: $1_def.r $1_ss.r  $1_sympar.r $1_simp.r
	ss_r2tex $1; latex_tidy $1_ss.tex 


#Linearised system: descriptor matrices
$1_dm.r: $1_dae.r $1_def.r $1_cr.r  $1_ss.r $1_sympar.r
	dae2dm_r $1; tidy $1_dm.r
$1_dm.m: $1_def.r $1_dm.r $1_sympar.r
		dm_r2m $1; matlab_tidy $1_dm.m
$1_dm.tex: $1_dm.r $1_sympar.r $1_simp.r 
	dm_r2tex $1; latex_tidy $1_dm.tex


#Linearised system: constrained-state matrices
$1_csm.r: $1_cse.r $1_def.r $1_cr.r $1_ss.r $1_sympar.r
	cse2csm_r $1; tidy $1_csm.r
$1_csm.m: $1_def.r $1_csm.r
		csm_r2m $1;  matlab_tidy $1_csm.m
$1_csm.tex: $1_csm.r  $1_sympar.r $1_simp.r
	csm_r2tex $1; latex_tidy $1_csm.tex

#Linearised system: transfer function
$1_tf.r: $1_dm.r $1_sympar.r 
	dm2tf_r $1; tidy $1_tf.r
$1_tf.m: $1_def.r $1_tf.r
	tf_r2m $1; matlab_tidy $1_tf.m
$1_tf.tex: $1_def.r $1_tf.r $1_sympar.r $1_simp.r
	tf_r2tex $1; latex_tidy $1_tf.tex


#Time responses
$1_ir.dat: $1_dm.m $1_numpar.m
	dm2ir_m2dat $1 '$4'
$1_sr.dat: $1_dm.m $1_numpar.m
	dm2sr_m2dat $1 '$4'

#Frequency responses
$1_fr.dat: $1_dm.m $1_numpar.m
	dm2fr_m2dat $1 '$4'

#Partially-known system indentification structure matrices
$1_pkim.r: $1_tf.r $1_sympar.r 
	tf2pkim_r $1; tidy $1_pki.r
$1_pkim.tex: $1_def.r $1_pkim.r $1_sympar.r
	pkim_r2tex $1; latex_tidy $1_pkim.tex

#Generic conversion of Latex to latex document
$1_$2.doc: $1_$2.tex
	showtex $1 $2

#Generic conversion of LaTeX doc to dvi
$1_$2.dvi: $1_$2.doc
	echo Creating $1_$2.dvi
	latex $1_$2.doc > /dev/null


#Create PostScript version of abg fig file
ifeq ('$2','abg')
$1_abg.ps: $1_abg.fig
	echo Creating $1_abg.ps
	fig2dev -Lps $1_abg.fig >$1_abg.ps
endif

#Create PostScript version of cbg fig file
ifeq ('$2','cbg')
$1_cbg.ps: $1_cbg.fig
	echo Creating $1_cbg.ps
	fig2dev -Lps $1_cbg.fig >$1_cbg.ps
endif

#Create PostScript version of dat file
ifeq ('$2','ir')
$1_$2.ps: $1_$2.dat
	dat2ps $1_$2
endif

ifeq ('$2','sr')
$1_$2.ps: $1_$2.dat
	dat2ps $1_$2
endif

ifeq ('$2','fr')
$1_$2.ps: $1_$2.dat
	dat2ps $1_$2
endif

#Generic conversion of dvi to ps
ifneq ('$2','abg')
ifneq ('$2','cbg')
ifneq ('$2','ir')
ifneq ('$2','sr')
ifneq ('$2','fr')
$1_$2.ps: $1_$2.dvi
	echo Creating $1_$2.ps
	dvips -o $1_$2.ps $1_$2.dvi 2> /dev/null
endif
endif
endif
endif
endif

#View a ps file
$1_$2.view: $1_$2.ps
	echo Creating view of $1_$2
	ghostview $1_$2.ps&

#Report generation
$1_rep.tex: $1_sum.tex $1_dae.tex $1_lbl.txt $1_sympar.r $1_cr.r \
            $1_abg.ps
	echo Creating $1_rep.tex 
	make_report $1 > $1_rep.tex


$1_rep.dvi: $1_rep.tex 	
	echo Creating $1_rep.dvi 
	latex $1_rep; latex $1_rep

$1_rep.ps: $1_rep.dvi
	echo Creating $1_rep.ps 
	dvips -o $1_rep.ps $1_rep

$1_rep.html: $1_rep.dvi
	echo Creating $1_rep.html 
	latex2html $1_rep.tex

# Clean up all intermediate files
$1_clean.: 
	echo Cleaning up system $1
	rm -f  *.log *.old *.met *.dvi *.aux *.f2bd
	rm -f  $1_abg.pl $1_cbg.pl  $1_ese.r $1_def.r \
	$1_tf.r  \
	$1_dae.r \
	$1_cse.r $1_dm.r $1_csm.r \
	$1_*_rep.tex \
        $1_rbg.m $1_abg.m $1_cbg.m $1_cbg.fig $1_cbg?.fig

EOF
