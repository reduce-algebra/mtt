#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt

# P.J.Gawthrop Oct 1989, Dec 1989, 1990, 1991, Oct 1993, Dec 1993, Jan 1994, Dec 95, Nov 1996.
# Copyright (c) P.J.Gawthrop, 1989, 1990, 1991, 1993, 1994, 1995, 1996, 1997,1998,1999
# Copyright (C) 2000 by Peter J. Gawthrop

###############################################################
## Version control history
###############################################################
## $Header$
## $Log$
## Revision 1.290  2000/12/05 09:59:37  peterg
## Generates $1_cr.h - allows inclusion of c functions for crs
##
## Revision 1.289  2000/12/05 09:01:52  peterg
## Changed == to =
##
## Revision 1.288  2000/12/01 17:59:01  peterg
## Added .PRECIOUS: %.cc to hang on to cc files - thanks Geraint
##
## Revision 1.287  2000/12/01 16:04:24  peterg
## More partitioning achieved -- now needs the connections to be properly
## sorted in cbg2ese_r
##
## Revision 1.286  2000/12/01 14:18:44  peterg
## -partition now partially works up to cse.m
##   but need to think about indexing, struc files etc for subsystems.
##
## Revision 1.285  2000/11/27 11:51:21  peterg
## Fixed a few pdf /fig bugs
##
## Revision 1.284  2000/11/27 10:33:35  peterg
## -pdf option now coerces ps-->pdf
##
## Revision 1.283  2000/11/24 15:11:50  peterg
## -pdf switch for simple displays
##
## Revision 1.282  2000/11/24 14:53:53  peterg
## Added lagrange rep : lde.r and lde.tex
##
## Revision 1.281  2000/11/16 13:51:15  peterg
## Added units stuff
##
## Revision 1.280  2000/11/10 14:45:16  peterg
## Finished up changes to incorporate Geraint's cc stuff
##
## Revision 1.279  2000/11/08 09:51:52  peterg
## Started incorporating Geraints CC/oct conversions
##
## Revision 1.278  2000/11/07 16:39:21  peterg
## *** empty log message ***
##
## Revision 1.277  2000/10/17 09:54:07  peterg
## logic rep sorted out
##
## Revision 1.276  2000/10/15 09:30:31  peterg
## *** empty log message ***
##
## Revision 1.275  2000/10/12 18:38:47  peterg
## New method of sympar generation implemented - uses mtt_make_sympar
## Check/update of numpar.txt is forced.
##
## Revision 1.274  2000/10/12 15:11:54  peterg
## Added the update function for numpar only
##
## Revision 1.273  2000/10/10 21:00:27  peterg
## More changes for new code gneration
##
## Revision 1.272  2000/10/06 16:20:00  peterg
## added ode_write rule
##
## Revision 1.271  2000/10/03 12:14:25  peterg
## Version 4.8
##
## Revision 1.270  2000/10/03 12:13:51  peterg
## Corrected MTT_LIB paths
##
## Revision 1.269  2000/09/30 14:12:03  peterg
## Fixed bug with no-parameter systems - changed mtt_txt2m and mtt_m2p
##
## Revision 1.268  2000/09/27 16:15:55  peterg
## Now sh (as opposed to bash) compatible -  fixed dat22dat again
##
## Revision 1.267  2000/09/21 10:08:30  peterg
## Version 4.7.1 - bug in odes.dat representation fixed in dat22dat
##
## Revision 1.266  2000/09/19 07:47:38  peterg
## fig2dev back to eps - ps produces a4 style output.
##
## Revision 1.265  2000/09/19 07:45:28  peterg
## Version 4.7
##
## Revision 1.264  2000/09/15 08:37:27  peterg
## Fixed bug using -sub in cbg view
##
## Revision 1.263  2000/09/15 07:33:35  peterg
## Replace fig2dev language eps by ps to avoid version problem.
##
## Revision 1.262  2000/09/14 17:16:33  peterg
## Fixes some outstanding bugs:
##   perpendicular strokes in cbg.fig
##   proper display of hierachical cbg file (-sub and -viewlevel)
##
## Revision 1.261  2000/09/14 12:43:46  peterg
## view of ps s files now uses -sub and -viewlevel options
##
## Revision 1.260  2000/09/14 09:59:08  peterg
## Added -viewlevel switch
##
## Revision 1.259  2000/09/11 08:21:27  peterg
## Introduced MML - but for _tf rep only.
##
## Revision 1.258  2000/09/11 08:17:28  peterg
## Extended _simp.r to incude default switches
##
## Revision 1.257  2000/09/02 15:53:53  peterg
## Now does partitioning up to dae.view
##
## Revision 1.256  2000/09/02 14:24:06  peterg
## -sub switch introduced - works up to dae.r
##
## Revision 1.255  2000/08/30 11:43:04  peterg
## Put in the -opt switch for code optimisation
##
## Revision 1.254  2000/08/29 09:59:47  peterg
## Version 4.5 -- includes code optimisation using the "Scope" package in reduce
##
## Revision 1.253  2000/08/24 08:53:35  peterg
## New makesubs to create a .subs.r file with output switches to simplify output.
##
## Revision 1.252  2000/08/09 10:31:17  peterg
## Use -d option to find if its a book-style report
##
## Revision 1.251  2000/08/04 10:54:33  peterg
## Rationalised call to gcc using -lp2c to access p2c lib.
##
## Revision 1.250  2000/08/01 19:29:27  peterg
## Explcit zero of input in the simulations
##
## Revision 1.249  2000/08/01 12:28:02  peterg
## VERSION 4.4
##    euler now works
##    stepfactor applies to both int. algorithms
##
## Revision 1.248  2000/07/20 07:46:07  peterg
## Version 4.3
##
## Revision 1.247  2000/07/13 07:21:12  peterg
## Interface to Octave Control Systems Toolbox (OCST) - mtt2sys.m
##
## Revision 1.246  2000/05/21 18:00:11  peterg
## Make manual if not already done.
## Released 4.2 version
## (Train Durham -- Glasgow).
##
## Revision 1.245  2000/05/19 17:50:10  peterg
## Changes to state rep - now has parameter
##
## Revision 1.244  2000/05/19 14:19:46  peterg
## Added library path for representations
##
## Revision 1.243  2000/05/19 11:36:36  peterg
## Added logic rep.
##
## Revision 1.242  2000/05/18 20:12:02  peterg
## Version 4.2
##
## Revision 1.241  2000/05/16 11:42:14  peterg
## Addded /usr/lib/libp2c.a  to gcc
##
## Revision 1.240  2000/05/10 09:38:58  peterg
## Added Make to list of copied files.
##
## Revision 1.239  2000/04/11 18:08:33  peterg
## Fixed cse.tex bug
##
## Revision 1.238  2000/04/10 10:06:41  peterg
## Sorted out implicit rules for p2oct conversion
##
## Revision 1.237  2000/04/07 19:10:24  peterg
## New smxa and smxax reps
##
## Revision 1.236  2000/04/06 10:55:36  peterg
## Removed debug lines
##
## Revision 1.235  2000/04/06 10:52:53  peterg
## Replace $PWD with `pwd` for sh compatibility
##
## Revision 1.234  2000/04/04 16:14:08  peterg
## Sorted mtt help
##
## Revision 1.233  2000/03/16 10:16:11  peterg
## Clean no longer zaps the abg.m files
##
## Revision 1.232  2000/03/16 09:43:35  peterg
## Put in $mtt_switches in mtt comand line when creating _state.txt and
## _input.txt
##
## Revision 1.231  2000/03/15 21:24:23  peterg
## Version 4.1:
##   Fixed problems with -abg mode
##   Old-style SS lbl no longer supported
##
## Revision 1.230  2000/03/15 20:31:06  peterg
## Replaced lbl2cr by abg2cr_m2txt
##
## Revision 1.229  2000/03/15 19:39:40  peterg
## Replaced sub creation cmp2sub_m2sh by abg2sub_m2sh
##
## Revision 1.228  2000/03/07 10:54:14  peterg
## Added  $1_lbl.txt to sympar.txt
##
## Revision 1.227  2000/02/16 15:05:46  peterg
## Replaced spurious 8spaces by tab
##
## Revision 1.226  2000/02/10 18:51:31  peterg
## Included OFF exp; in subs.r default
##
## Revision 1.225  2000/02/10 15:03:10  peterg
## Put subs.r file into the m-code generation -- allows the off exp;
## switch for simpler expresions.
##
## Revision 1.224  2000/02/08 10:27:04  peterg
## Removed obselete .h stuff
##
## Revision 1.223  2000/02/08 09:55:00  peterg
## Added .oct language for ode
## -- octave loadable builtin
##
## Revision 1.222  1999/12/23 10:03:42  peterg
## Added $1_sympars.txt to numpar.m target
##
## Revision 1.221  1999/12/22 05:15:51  peterg
## Set to version 4.0.
##
## Revision 1.220  1999/12/17 03:17:57  peterg
## reps_made is now $1_reps_made - stops clash between two reps per directory
##
## Revision 1.219  1999/12/14 00:36:50  peterg
## Changed $source to $stdin and added to mtt_m2p arg list
##
## Revision 1.218  1999/12/03 00:04:50  peterg
## Version to eric.
## -stdin switch added
##
## Revision 1.217  1999/11/16 22:15:55  peterg
## Changed compcopy to test for abg, not lbl file
##
## Revision 1.216  1999/11/16 05:53:21  peterg
## Added sensitivity (-s) switch
##
## Revision 1.215  1999/11/15 22:45:31  peterg
## Reorganised integration method using -i switch
## Introduced -r (reset) switch
##
## Revision 1.214  1999/11/14 21:27:11  peterg
## *** empty log message ***
##
## Revision 1.213  1999/09/02 23:24:40  peterg
## Now explicitly generates executable _ode2odes.out file
## Which takes command line arguments
##
## Revision 1.212  1999/08/18 06:20:32  peterg
## Put -u back again .....
##
## Revision 1.211  1999/08/17 04:10:38  peterg
## Removed the -u switch from cp - it doesnt work on non GNU cps
##
## Revision 1.210  1999/08/02 12:52:12  peterg
## Removed redundant .p copying.
##
## Revision 1.209  1999/07/27 03:50:13  peterg
## Fixed odeo.p bug.
## Fixed compound object bug in fig.
##
## Revision 1.208  1999/07/20 23:43:05  peterg
## V 3.8 ( to Eric)
##
## Revision 1.207  1999/04/02 07:17:37  peterg
## Upped version to 3.6 -- the new implicit solver with switches
##
## Revision 1.206  1999/04/02 06:28:54  peterg
## New implicit method - solves numerical prob with ISW
##
## Revision 1.205  1999/03/15 23:27:43  peterg
## Modified generation of odes.dat2 data
##
## Revision 1.204  1999/03/15 05:53:33  peterg
## Put in user-defined representations
##
## Revision 1.203  1999/03/08 03:51:12  peterg
## Version 3.5 for Linux Red Hat 5.2 (Newcastle)
##
## Revision 1.202  1999/02/17 01:59:20  peterg
## Now handles html copy correctely (ie mv directory to ..)
## Fixed path probs with html
##
## Revision 1.201  1999/02/16 03:50:09  peterg
## Removed explicit _smx targets
##
## Revision 1.200  1998/12/03 17:11:03  peterg
## Added -dc (derivative causality) switch.
##
## Revision 1.199  1998/12/03 16:53:50  peterg
## Now completes causality using component, not bond, status.
##
## Revision 1.198  1998/11/20 16:12:30  peterg
## Now copies aliased systems BEFORE generating rgb etc.
##
## Revision 1.197  1998/11/20 09:00:45  peterg
## Number of changes to underlying tools
##
## Revision 1.196  1998/11/10 11:55:40  peterg
## Added $info_switch to abg2cbg invocation
##
## Revision 1.195  1998/10/28 13:58:57  peterg
## Added $1_sympars.txt prerequisite to _tf.m target
##
## Revision 1.194  1998/10/20 09:00:43  peterg
## Added a few summary lines - to help with xmtt
##
## Revision 1.193  1998/10/01 16:11:42  peterg
## Implicit integration now handles switches
##
## Revision 1.192  1998/09/29 20:09:46  peterg
## Fixed nyfr and nifr plotting bug
##
## Revision 1.191  1998/09/02 12:05:39  peterg
## Added INPUT to simpar
##
## Revision 1.190  1998/09/02 11:48:51  peterg
## VERSION 3.2 (Swansea)
## abg data structure now uses explicti port and subsystem lists so that
## processing is in predetermined order.
##
## Revision 1.189  1998/08/31 10:49:15  peterg
## Minor changes to -abg operation
##
## Revision 1.188  1998/08/27 08:33:21  peterg
## New reduce integration methods - euler/Implicit only
##
## Revision 1.187  1998/08/25 20:06:56  peterg
## New data structure for abg.m and cbg.m
##
## Revision 1.186  1998/08/18 10:49:05  peterg
## VERSION 3.1 release
##
## Revision 1.185  1998/08/18 09:21:14  peterg
## Removed "" from default simpar file.
##
## Revision 1.184  1998/08/18 09:08:26  peterg
## Now grabs components (specified in lbl file as alias) at the rbg stage
## - this makes sure that they are there when needed.
##
## Revision 1.183  1998/08/18 08:48:43  peterg
## Sorted out problem with ifeq ($REPTYPE,data) block - added else.
##
## Revision 1.182  1998/08/17 15:48:39  peterg
## Replaced SVD solver with LUD solver
##
## Revision 1.181  1998/08/15 13:45:28  peterg
## Added new integration methods in Pascal/c version
## Revised the various translations appropriately
##
## Revision 1.180  1998/08/12 14:15:13  peterg
## Implicit integration - c implemetation now included.
##
## Revision 1.179  1998/08/12 12:29:18  peterg
## Put back some of the args stuff -- needed for plots.
##
## Revision 1.178  1998/08/11 13:38:35  peterg
## Zapped the obsolete args stuff
##
## Revision 1.177  1998/07/30 17:32:44  peterg
## VERSION 3.0
##
## Revision 1.176  1998/07/27 20:25:15  peterg
## Sorted out new mtt_r2m
##
## Revision 1.175  1998/07/27 18:49:09  peterg
## Fixed the frequency stuff
##
## Revision 1.174  1998/07/27 07:10:10  peterg
## Removed dummy global stuff.
##
## Revision 1.173  1998/07/26 14:38:20  peterg
## *** empty log message ***
##
## Revision 1.172  1998/07/26 11:13:38  peterg
## Fixed name classes with globs - ide is that all @strong{MTT} variables
## start with @strong{MTT}
##
## Revision 1.171  1998/07/25 20:37:22  peterg
## Removes -s (switches) option -- they are now assumed to be present
## I still need to shift the old switch
##
## Revision 1.170  1998/07/25 19:16:22  peterg
## Sorted out sympar + switch variables - new sympars rep combines both
##
## Revision 1.169  1998/07/25 16:35:12  peterg
## Incorporated mtt_p2c (uses p2c)
##
## Revision 1.168  1998/07/25 09:44:25  peterg
## Uses Pascal as step on the way to c code -- MUCH nicer!
## State and input now use the simple default - no steady states
##
## Revision 1.167  1998/07/24 17:10:34  peterg
## *** empty log message ***
##
## Revision 1.166  1998/07/22 08:37:30  peterg
## Implicit integration now the default - for octave anyway.
##
## Revision 1.165  1998/07/19 16:00:22  peterg
## Added smx representation
##
## Revision 1.164  1998/07/17 19:45:58  peterg
## Component aliases implemented.
##
## Revision 1.163  1998/07/17 08:27:33  peterg
## Added find target
##
## Revision 1.162  1998/07/16 16:14:27  peterg
## Now stops if a transformation forces error.
##
## Revision 1.161  1998/07/08 11:21:32  peterg
## Added -I switch
##
## Revision 1.160  1998/07/04 11:38:51  peterg
## Version 3.0-- (Seascale)
##
## Revision 1.159  1998/07/04 11:37:43  peterg
## Aliases implemented for parameters + lots of associated goodies
## New-style lbl files - no more SS nonsense.
##
## Revision 1.158  1998/07/03 09:06:39  peterg
## Alias implemented for ports
##
## Revision 1.157  1998/07/01 10:22:11  peterg
## Moved tidy stuff to end of preamble -- needed to make muti-plot copy
## correctely
## Now copies ps file with arguments to WD
##
## Revision 1.156  1998/06/26 14:19:43  peterg
## Copy hidden files (eg .octaverc) in tidy mode
##
## Revision 1.155  1998/06/24 07:43:42  peterg
## Version 2.91 -- includes implicit integration (octave)
##
## Revision 1.154  1998/06/17 14:14:09  peterg
## Removed struc.txt prerequisite for simpar.txt - switch version
##
## Revision 1.153  1998/05/28 09:36:38  peterg
## --version and --versions switch
##
## Revision 1.152  1998/05/24 15:43:10  peterg
## Added symbolic solution of alg. equations (-A)
##
## Revision 1.151  1998/05/23 16:18:37  peterg
## ordinary differential equation.m files generated with the new ode2lang
## method.
##
## Revision 1.150  1998/05/19 19:47:37  peterg
## Updated the odesso representation to use simpar file.
##
## Revision 1.149  1998/05/14 15:16:13  peterg
## Sorted out Differential-Algebraic Equation simulation
## Added LSODE methode to ordinary differential equation simulation
##
## Revision 1.148  1998/05/12 14:42:07  peterg
## Added ese_tidy and new method for organising ese files -
## Each subsystem has an array of variables - effort, flow and state for
## each bond
##
## Revision 1.147  1998/04/15 18:41:47  peterg
## Fixed various probs with multiple systems in one directory
##
## Revision 1.146  1998/04/04 11:00:20  peterg
## Modified various parts to allow coercing directions at ports
##
## Revision 1.145  1998/04/03 11:17:44  peterg
## VERSION 2.9
##
## Revision 1.144  1998/03/27 13:32:25  peterg
## Removed sympar prerequisites from ss reps.
##
## Revision 1.143  1998/03/22 21:14:03  peterg
## Added obspar.r representation
## Help now case insensitive
##
## Revision 1.142  1998/03/20 15:09:26  peterg
## Changed order of prerequisites for _dae.r to put _rdae.r first.
##
## Revision 1.141  1998/03/11 10:45:19  peterg
## Added rclean - recursive clean
##
## Revision 1.140  1998/03/09 10:23:30  peterg
## PS view now runs as a background process.
##
## Revision 1.139  1998/03/07 16:04:23  peterg
## Added some more txt view reps: input, lbl, numpar, state
##
## Revision 1.138  1998/03/07 15:23:40  peterg
## Uses sort_sympar to uniquely produce the sympar list.
##
## Revision 1.137  1998/03/07 14:04:17  peterg
## dae creation split into 2 parts:
## 1. create a raw (ie without constitutive relationship) dae (rdae)
## 2. add the raw dae to the crs to get the dae.
## reduce has less work to do with this approach
##
## Revision 1.136  1998/03/04 16:34:19  peterg
## New local (_cr.r) and generic (.cr) CR structure.
## CR and lbl now have view mode.
## CRS in abg_tex.
##
## Revision 1.135  1998/02/25 22:09:48  peterg
## Added simpar representation.
##
## Revision 1.134  1998/02/25 15:28:34  peterg
## Added state.m rep.
##
## Revision 1.133  1998/02/24 22:35:33  peterg
## Added -p (preserve) switch to cp in tidy mode.
##
## Revision 1.132  1998/02/24 22:33:23  peterg
## new state reresentation included
##
## Revision 1.131  1998/02/23 16:21:21  peterg
## Just do model name in summary line of lbl file
##
## Revision 1.130  1998/02/19 13:40:24  peterg
## Removed prerequisit from sspar.r target.
##
## Revision 1.129  1998/02/12 08:18:42  peterg
## VERSION 2.8 (St. Annes)
##
## Revision 1.128  1998/02/12 07:48:04  peterg
## Tidy mode copies all files (containing .) to work dir -- this makes
## sure that files such a .c .constitutive relationship go across.
##
## Revision 1.127  1998/02/11 19:36:29  peterg
## Only displays one level of cbg file now.
##
## Revision 1.126  1998/02/11 19:26:03  peterg
## Added verbose (-v) mode.
##
## Revision 1.125  1998/02/11 11:36:28  peterg
## Updated version control mode - make it untidy.
## cp --> cp -u after tidy-mode .
##
## Revision 1.124  1998/02/10 13:03:36  peterg
## Now includes controller transfer function (ctf).
##
## Revision 1.123  1998/02/09 13:51:04  peterg
## Fixed directory string bug.
##
## Revision 1.122  1998/02/06 15:02:26  peterg
## New default sspar -- sets all states to zero.
##
## Revision 1.121  1998/02/06 14:36:51  peterg
## Report on copying back from MTT_work
##
## Revision 1.120  1998/02/05 16:06:53  peterg
## Removed debugging lines.
## Auto parts in books.
##
## Revision 1.119  1998/02/05 15:04:25  peterg
## Fixed problem with book in tidy mode.
##
## Revision 1.118  1998/02/05 12:00:11  peterg
## Tidy mode now default.
## It seems to work ok but not for book type documents.
##
## Revision 1.117  1998/02/04 16:50:50  peterg
## Introduced the tidy (-t and -T) options
##
## Revision 1.116  1998/02/04 11:00:04  peterg
## Added view of subsystems.
##
## Revision 1.115  1998/01/29 19:37:31  peterg
## Fixed spurious call to X server bug
##
## Revision 1.114  1998/01/23 13:38:07  peterg
## VERSION 2.7
##
## Revision 1.113  1998/01/23 13:27:13  peterg
## Added state-feedback control representations:
## smc,smo,ssk,ssl
##
## Revision 1.112  1998/01/21 09:24:46  peterg
## Removed 'touch $1_rep.txt' -- perhaps best to do this by hand if
## necessary. As it is, it cuased probs wene reediting the _rep.txt file.
##
## Revision 1.111  1998/01/16 14:56:59  peterg
## Argument now correctely recognised as a string beginning with -
## (rather than containing -)
##
# Revision 1.110  1998/01/06  13:59:30  peterg
# Added rename function.
#
# Revision 1.109  1998/01/06  09:20:02  peterg
# Made LATEX2HTML an environment variable.
#
# Revision 1.108  1997/12/19  08:48:55  peterg
# Lille modifications - bicausal algebraic loops supported
#
## Revision 1.107  1997/12/11 10:59:50  peterg
## This is version 2.6
##
# Revision 1.106  1997/12/11  10:59:07  peterg
# Added debug -D switch + echos directory when -d switch used.
#
# Revision 1.105  1997/12/11  09:04:47  peterg
# Reduced default rep.txt file to just abg.txt -- this is to document
# components which may not be causally complete
#
# Revision 1.104  1997/12/07  21:05:10  peterg
# Removed a debbugging echo
#
## Revision 1.103  1997/12/07 20:10:36  peterg
## Fixed bugs with reprots and distinguish between book, article and
## section reports.
##
## Revision 1.102  1997/12/07 12:14:43  peterg
## Hnadles book, article and section reports seperately
##
## Revision 1.101  1997/12/06 18:54:53  peterg
## Now tidies up after itself.
## Major modifications to do a rep on a directory -- creates a book with
## each example as a chapter.
##
## Revision 1.100  1997/12/06 12:14:39  peterg
## Put a conditional around the PS data rep to check for set arguments.
##
## Revision 1.99  1997/12/04 22:06:53  peterg
## Added view arguments for graph plotting
##
## Revision 1.98  1997/12/04 10:58:15  peterg
## Tidied up switches
##
## Revision 1.97  1997/12/04 10:44:33  peterg
## Changed $cc to $CC
##
## Revision 1.96  1997/12/04 10:40:26  peterg
## Added -p switch - print enviromment variables
##
## Revision 1.95  1997/12/04 10:05:02  peterg
## Compiler now symbolocic $cc
##
# Revision 1.94  1997/11/20  11:23:16  peterg
# Changed gcc to cc
#
## Revision 1.93  1997/09/18 16:57:28  peterg
## _sympar.txt now has a second column - the system type from whence the
## parameter (in the first column) came.
## Done on the train Glasgow-Warrington !
##
## Revision 1.92  1997/09/11 17:08:46  peterg
## Added spreadsheet version of odeso
##
## Revision 1.91  1997/09/11 08:21:08  peterg
## copy utility split into two:
## copy: copies examples (copies the entire directory)
## compcopy: (just used internally) copies components.
##
## Revision 1.90  1997/08/30 19:35:39  peterg
## Added date to mtt line
##
## Revision 1.89  1997/08/26 15:20:25  peterg
## Added explicit evaluation of report representations
## Version now 2.5++
##
## Revision 1.88  1997/08/25 07:51:47  peterg
## Version 2.5.
##
## Revision 1.87  1997/07/27 13:11:11  peterg
## Added path checking code -- mtt_check_vars
##
# Revision 1.86  1997/06/29  19:05:51  peterg
# Seascale changes -- mainly to new rep format.
#
## Revision 1.85  1997/06/27 12:14:49  peterg
## Upped version to 2.4++
##
# Revision 1.84  1997/06/13  14:08:23  peterg
# Changed default rep.txt
#
# Revision 1.83  1997/06/13  09:18:28  peterg
# Removed all params.m
#
# Revision 1.82  1997/06/13  08:59:03  peterg
# Set to version 2.4
#
## Revision 1.81  1997/05/22 10:11:04  peterg
## Fixed dat2gdat bug (with parameters)
##
## Revision 1.80  1997/05/22 07:38:27  peterg
## Added command line info to .doc files (makedoc)
##
## Revision 1.79  1997/05/19 16:44:12  peterg
## Many changes to get rep.html mode working properly.
##
# Revision 1.78  1997/05/19  13:17:50  peterg
# Explicit inclusion of mtt.sty in .doc files -- latex2html prefers this
#
# Revision 1.77  1997/05/19  11:29:37  peterg
# Added desc.tex and abg.tex descriptions.
#
# Revision 1.76  1997/05/15  09:43:46  peterg
# New version of _input.txt for -s option
#
# Revision 1.75  1997/05/15  09:15:54  peterg
# Included switch.c in dependancy list for _input.c (when -s switch set)
#
# Revision 1.74  1997/05/13  16:58:02  peterg
# Added -s switch to get mtt to search for (Bond Graph) switches
#
## Revision 1.73  1997/05/09 09:18:45  peterg
## Put ./ in front of a.out (again)
##
# Revision 1.72  1997/05/06  13:54:21  peterg
# Changed gcc arguments for the ode simulation -- all files now included
# in the _odes.c file
#
# Revision 1.71  1997/05/03  15:50:18  peterg
# c functions not included in gcc arg list -- they are now included in
# the main prog.
#
# Revision 1.70  1997/05/03  14:17:13  peterg
# Now copies c utilities (eg dsvdcmp.c) from $MTTPATH/trans/c.
#
# Revision 1.69  1997/05/03  13:58:35  peterg
# Implicit integration for sm representation added.
#
# Revision 1.68  1997/05/01  08:39:20  peterg
# params.c and params.m not used any more.
# _numpar.txt is the common base from which _numpar.c and numpar.m is
# generated.
#
# Revision 1.67  1997/04/23  07:26:49  peterg
# Added -o switch -- ode and dae are the same
# Added switches to default menu
#
# Revision 1.66  1997/04/16  09:46:01  peterg
# More informative copy message
#
# Revision 1.65  1997/04/15  15:16:12  peterg
# Added structure (_struc) files.
# Fixed prob with dvi2ps conversion -- removed .doc extension.
#
# Revision 1.64  1997/04/09  09:26:44  peterg
# Added crcopy feature to pull crs from library -- similar to copy
# feature.
#
# Revision 1.63  1997/03/22  17:09:11  peterg
# Fixed bug in recursive cr.txt generation.
# Fixed bug in recursive sympar.txt generation.
#
# Revision 1.62  1997/03/20  17:48:50  peterg
# Better _input.c file default.
#
# Revision 1.61  1997/03/20  16:53:01  peterg
# Generates c files using include statements.
#
# Revision 1.60  1997/03/20  10:25:41  peterg
# Generates a compehensive default params file.
#
# Revision 1.59  1997/03/19  10:14:04  peterg
# Now produces a stripped acausal bond graph.
#
# Revision 1.58  1997/03/18  17:58:12  peterg
# Generates label files containing all variables in fig file.
# Generates sympar file for all levels in system.
# Generates txt version of sympar file.
#
# Revision 1.57  1997/03/10  09:24:58  peterg
# a.out now deleted in the clean operation
#
# Revision 1.56  1997/03/05  08:24:09  peterg
# Delete a.out after it has run.
#
# Revision 1.55  1997/02/24  19:31:10  peterg
# Removed numpar.m requirement from .m files
#
## Revision 1.54  1997/02/09 20:33:13  peterg
## Replaced a.out with ./a.out
##
## Revision 1.53  1997/02/09 20:30:04  peterg
## Copied from tweedledum.
##
# Revision 1.54  1997/02/07  13:33:03  peterg
# Added ; to _input.c file - bug fix.
#
# Revision 1.53  1997/02/07  13:25:04  peterg
# Version 2.3
#
# Revision 1.52  1997/01/21  22:55:59  peterg
# Minor bug fixes
#
## Revision 1.51  1997/01/21 13:16:40  peterg
## Included transformations to language c for:
## ode
## params
## numpar
##
## Revision 1.50  1996/12/21 19:46:52  peterg
## Set to 2.2++
## Changed \* --> \\* in rbg_fig2m.awk
##
## Revision 1.49  1996/12/19 19:55:22  peterg
## Version 2.2 -- Linux.
##
## Revision 1.48  1996/12/07 21:33:52  peterg
## Changed _input file to give unit step on ALL inputs
##
## Revision 1.47  1996/12/07 20:50:16  peterg
## *** empty log message ***
##
## Revision 1.46  1996/12/05 10:48:51  peterg
## Put sympar in clean list.
## sympar now sucks in params.r file
##
## Revision 1.45  1996/12/05 10:41:39  peterg
## Saved many changes over past 2 weeks.
##
# Revision 1.44  1996/11/12  16:04:25  peterg
# Really VERSION 2.1
#
# Revision 1.43  1996/11/12  08:52:57  peterg
# Fixed bug in test arg to if - missing "".
#
# Revision 1.42  1996/11/11  17:23:03  peterg
# Added numpar.m requirement to all .m targets
#
## Revision 1.41  1996/11/11 17:18:32  peterg
## VERSION 2.1
##
## Revision 1.40  1996/11/09 21:17:38  peterg
## Fixed bug with copying at level 0.
##
## Revision 1.39  1996/11/09 20:22:54  peterg
## VERSION 2.0
##
## Revision 1.38  1996/11/09 20:17:34  peterg
## Fixed bug with null ARGS argument
## Put in new lib paths.
##
## Revision 1.37  1996/11/09 18:47:46  peterg
## Added new copy command (using find).
## More documaentation stuff.
##
# Revision 1.36  1996/11/03  21:19:02  peterg
# Recursice generation of Constitutive Relationship files.
#
## Revision 1.35  1996/11/02 10:19:19  peterg
## Constitutive Relationship generation from lbl file
##
## Revision 1.34  1996/11/01 13:34:35  peterg
## -q (quiet) switch added
##
## Revision 1.33  1996/11/01 12:34:45  peterg
## Added browser - mtt_help
##
## Revision 1.32  1996/10/31 20:48:41  peterg
## Revised html generation.
## Stopped deletion of rep.txt file.
##
# Revision 1.31  1996/10/20  19:23:54  peterg
# Automatic generation of sub-system abg.m files.
#
## Revision 1.30  1996/10/01 14:08:05  peterg
## Replaced $() by ``
## Replaced make with gmake
##
# Revision 1.29  1996/10/01  11:04:05  peter
# Changed name of html document.
#
## Revision 1.28  1996/09/13 18:44:11  peter
## Added params dependencies.
##
## Revision 1.27  1996/09/12 19:24:56  peter
## New numpar/params setup.
##
## Revision 1.26  1996/09/10 17:04:47  peter
## Added impulse response (ir) representation.
##
## Revision 1.25  1996/08/30 20:03:45  peter
## Removed dependencies from vc
##
## Revision 1.24  1996/08/30 18:37:17  peter
## inor changes.
##
## Revision 1.23  1996/08/30 11:10:37  peter
## More files in clean up.
##
## Revision 1.22  1996/08/30 10:07:51  peter
## Removed impicit creation of abg.fig file.
##
## Revision 1.21  1996/08/22 12:19:51  peter
## Added various document viewers.
##
## Revision 1.20  1996/08/20 08:24:53  peter
## Now with version control.
##
## Revision 1.19  1996/08/19 15:33:22  peter
## Included new state matric (sm) rep.
## Generate step response (sr) from sm.
##
## Revision 1.18  1996/08/19 13:30:54  peter
## New CLEAN target.
##
## Revision 1.17  1996/08/19 06:48:14  peter
## Explicit figure editing.
##
## Revision 1.16  1996/08/18 19:58:36  peter
## Report generation included.
##
## Revision 1.15  1996/08/18 12:01:01  peter
## Unified format of time responses.
##
## Revision 1.14  1996/08/16 14:52:24  peter
## Added two alternative view options - dview and pview.
##
## Revision 1.13  1996/08/16 08:24:31  peter
## Correctly chooses how to make a ps file using $REPTYPE.
##
## Revision 1.12  1996/08/15 16:47:47  peter
## DAE solution (experimental) included.
##
## Revision 1.11  1996/08/15 11:55:30  peter
## Checks for changed argument.
## Handles frequency response.
##
## Revision 1.10  1996/08/15 07:44:24  peter
## Now handles generic transformations using %.
##
## Revision 1.9  1996/08/14 09:16:08  peter
## Step response now goes through  m, dat and gdat conversions
##
## Revision 1.8  1996/08/12 20:19:52  peter
## Arguments now passed via $1_args.m file
##
## Revision 1.7  1996/08/11 19:49:27  peter
## Parameter passing (via $4) added.
##
## Revision 1.6  1996/08/11 10:40:56  peter
## Added new numpar stuff.
## Added step response.
##
## Revision 1.5  1996/08/10 14:13:47  peter
## Added impulse and frequency response stuff.
##
## Revision 1.4  1996/08/10 09:19:48  peter
## Put in help, info and warranty stuff.
##
## Revision 1.3  1996/08/09 15:13:13  peter
## Generic viewing of any representation via ps files implemented.
##
## Revision 1.2  1996/08/05 19:50:55  peter
## Put in fig.fig target.
##
## Revision 1.1  1996/08/04 17:29:42  peter
## Initial revision
##
###############################################################


#Check $MTTPATH has been set
mtt_check_var "$MTTPATH" "MTTPATH"

#Version
version='4.9'

# MTT recursion level is zero unless explicitly set
level=0

#Computation mode is octave by default
computation=octave

#By default, the dae and ode representations are different
dae_is_ode=0

#By default, the ode and cse reps are different
ode_is_cse=0

# By default, don't look for BG switches
switches=0

#By default, don't print the environment variables
print='';

# By default, make it tidy
tidy=tidy;

# Default not verbose
verbose=' -s'

# Default integration method
integration_method=implicit;

# Default no info
info_switch=''

# Default use m, not oct files
m='m';

# Default use ps files
ps=ps
eps=eps
psview=$PSVIEW

#Initialise list
mtt_switches='';


#Look for a command line argument
while [ -n "`echo $1 | grep '^-'`" ]; do
  case $1 in
	-q )
                mtt_switches="$mtt_switches $1";
		quiet=quiet;;  
	-r )
                mtt_switches="$mtt_switches $1";
		reset=reset;;  

	-p )
                mtt_switches="$mtt_switches $1";
		print='-p';;
	-c )
                mtt_switches="$mtt_switches $1";
                matrix_smxa="-matrix";
		computation=c ;;
	-cc )
                mtt_switches="$mtt_switches $1";
                matrix_smxa="-matrix";
		computation=cc ;;
	-o )
                mtt_switches="$mtt_switches $1";
		dae_is_ode=1 ;;
	-nocr )
                mtt_switches="$mtt_switches $1";
		rdae_is_dae=1 ;;
	-i )
                mtt_switches="$mtt_switches $1";
                shift;
                case $1 in
		    euler)
			integration_method=euler;
                        mtt_switches="$mtt_switches euler";
			;;
		    implicit)
			integration_method=implicit;
                        mtt_switches="$mtt_switches implicit";
			;;
		    *)
			echo $1 is an unknown integration method - use euler or implicit;
                        exit;;
		esac;;
	-s )
                mtt_switches="$mtt_switches $1";
		sensitivity=sensitivity ;;
	-ss )
                mtt_switches="$mtt_switches $1";
		steadystate_computation=yes ;;
	-d )
		directory=$2; cd $directory; shift ;;
	-dc )
		mtt_switches="$mtt_switches $1";
		causality_switch='-derivative' ;;
	-S )
		directory=$2;  shift;;
	-D )
                mtt_switches="$mtt_switches $1";
		debug=debug ;;
	-v )
                mtt_switches="$mtt_switches $1";
		info_switch='-I';
                Verbose='verbose';
		verbose=' -w ' ;;
	-I )
                mtt_switches="$mtt_switches $1";
		info_switch='-I' ;;
	-t )
		tidy=tidy ;;
	-T )
		tidy=tidy;
                verytidy=verytidy ;;
	-u )
		tidy=untidy ;
                mtt_switches="$mtt_switches $1";
                ;;
	-l )
                mtt_switches="$mtt_switches $1 $2";
		level=$2; shift ;;
	-A )
                mtt_switches="$mtt_switches $1";
                Solve='-A';;
	-abg )
                mtt_switches="$mtt_switches $1";
                start_at_abg='yes';;
	-stdin )
                mtt_switches="$mtt_switches $1";
                stdin=stdin;;
	-sub )  mtt_switches="$mtt_switches $1 $2";
                sub='-sub'; 
                subsystem="_"$2;
                shift;;
	-oct )
                mtt_switches="$mtt_switches $1";
                using_oct=yes;
                m=oct
                ;;
	-opt )  mtt_switches="$mtt_switches $1";
                optimise='-optimise';;
	-partition ) mtt_switches="$mtt_switches $1";
                     partition='-partition';
                ;;
	-pdf )   mtt_switches="$mtt_switches $1";
                 ps=pdf; 
                 eps=pdf;
                 pdf='-pdf';
                 psview=$PDFVIEW;
                ;;
	-viewlevel )  mtt_switches="$mtt_switches $1 $2";
                      viewlevel=$2;
                      shift;;
        --version)                
                  echo 'MTT version' $version; exit;;
        --versions)                
                mtt_versions; exit;;
	*)
		echo "$1 is an invalid argument - ignoring" ;;
  esac
  shift
done

#Print header if not in quiet (-q) mode.
if [ "$quiet" != "quiet" ]; then
  echo
  echo 'MTT (Model Transformation Tools) version' $version
  echo '($Date$)'
  echo 'This is free software with ABSOLUTELY NO WARRANTY.'
  echo 'Type `mtt warranty'\' 'for details.'
  echo
  # Print current directory if in -d mode
  if [ -n "$directory" ]; then
    echo Using directory $directory
    echo
  fi
fi

#Print what's going on if in verbose mode
if [ -n "$Verbose" ]; then
    echo  Starting  mtt  $mtt_switches  $1 $2 $3 $4 at level $level 
    echo  "        " current wd `pwd`
fi

#Check the principle paths
mtt_check_vars $print

# Exit if just printing paths
if [ "$print" != "" ]; then
  exit
fi

if [ -z "$1" ]; then
  if [ -z "$print" ]; then
    echo 'Usage: mtt help             -- mtt on-line help'
    echo '       mtt find component   -- find location of a compound component'
    echo '       mtt info             -- info-based manual'
    echo '       mtt info topic'
    echo '       mtt hinfo            -- hypertext manual'
    echo '       mtt manual           -- pdf manual'
    echo '       mtt warranty'
    echo '       mtt clean           -- cleans up intermediate files'
    echo '       mtt rclean          -- recursively cleans up intermediate files'
    echo '       mtt Clean           -- cleans up all generated files'
    echo '       mtt <system_name> clean'
    echo '       mtt copy <system_name> <path_name>'
    echo '       mtt rename <old_name> <new_name>'
    echo '       mtt <system_name> <representation> vc' 
    echo '       mtt <system_name> <representation> <language>'
    echo '       mtt <system_name> <representation> <language> <parameters>'
    echo 'Options: -q  quiet mode -- suppress MTT banner'
    echo '         -A  solve algebraic equations symbolically'
    echo '         -D  debug -- leave log files etc'
    echo '         -I  prints more information'
    echo '         -abg start at abg.m representation'
    echo '         -c  c-code generation'
    echo '         -d  <dir>  use directory <dir>'
    echo '         -dc Maximise derivative (not integral) causality'
    echo '         -dc Maximise derivative (not integral) causality'
    echo '         -i <implicit|euler>   Use implicit or euler integration'
    echo '         -o ode is same as dae'
    echo '         -oct use oct files in place of m files where appropriate'
    echo '         -opt optimise code generation'
    echo '         -p  print environment variables'
    echo '         -partition partition hierachical system'
    echo '         -r  reset time stamp on representation'
    echo '         -s  try to generate sensitivity BG (experimental)'
    echo '         -ss use steady-state info to initialise simulations'
    echo '         -stdin read input data from standard input for  simulations'
    echo '         -sub <subsystem> operate on this subsystem'
    echo '         -t  tidy mode (default)'
    echo '         -u  untidy mode (leaves files in current dir)'
    echo '         -v  verbose mode'
    echo '         -viewlevel <N> View N levels of hierachy'
    echo '         --version print version and exit'
    echo '         --versions print version of mtt and components and exit'
    exit
  fi
fi


if [ "$1" = "info" ]  && [ "$3" = "" ]; then
  (cd $MTTPATH/doc/; make --silent mtt.info)
  echo "Invoking info in xterm"
  xterm -e info -f $MTTPATH/doc/mtt.info $2
  exit
fi

if [ "$1" = "help" ]; then
  mtt_help $2 $3
  exit
fi

if [ "$1" = "hinfo" ] && [$2 = ""]; then
   mtt_check_var "$HTMLVIEW" HTMLVIEW
  (cd $MTT_DOC/; make --silent mtt.html) 
   echo Invoking $HTMLVIEW
   (cd $MTT_DOC; $HTMLVIEW ./mtt.html)&
   exit
fi

if [ "$1" = "manual" ] && [$2 = ""]; then
  mtt_check_var "$PDFVIEW" PDFVIEW
  (cd $MTT_DOC/; make --silent mtt.pdf) 
  echo Invoking $PDFVIEW 
  $PDFVIEW  $MTT_DOC/mtt.pdf &
  exit
fi

if [ $1 = "find" ]&& [$3 = ""]; then
    mtt_find $MTT_COMPONENTS $2
    find_status=$?
  if [ $find_status = "1" ]; then
    echo Component $2 not found - is MTT_COMPONENTS set correctly?
  fi
    exit $find_status
fi

if [ "$1" = "warranty" ] && [$2 = ""]; then
  cat << EOF
Copyright (C) 1989, 1990, 1991, 1992, 1993, 
              1994, 1995, 1996, 1997, 1998, 1999 Peter J. Gawthrop
This is free software with ABSOLUTELY NO WARRANTY.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

EOF
  exit
fi

# Start at abg representation
if [ -n "$start_at_abg" ]; then
  if [ -f "$1_abg.m" ]; then
    if [ "$quiet" != "quiet" ]; then
        echo Starting from $1_abg.m
    fi
  else
    echo $1_abg.m does not exist
    exit
  fi
fi

# Clean up 
if [ "$1" = "clean" ]; then
  echo Removing intermediate files in `pwd`
  rm -fr MTT_work
  exit
fi

# Recursively clean up
if [ "$1" = "rclean" ]; then
  echo 'Removing intermediate files recursively'
  dir2paths '.' | awk '{print "mtt -q -d " $1 " clean " $2}' | sh
  exit
fi

# The big clean up
if [ "$1" = "Clean" ] && [ "$2" = "" ]; then
  echo 'Removing all generated files for all systems'
  rm -f *.log  mtt_info.txt warning.txt
  rm -f *_abg.ps *_args.*  *_cr.txt *_abg.tex
  rm -f *_sabg.fig *_sabg.ps *_head.fig *_bnd.fig 
  rm -f *_sympar.r *_sympar.c *_sympar.h *_sympar.txt? *_sympar.tex
  rm -f *_rbg.* *_cmp.* *_fig.fig *_*cbg.* *_ese.* *_def.* *_alias.*
  rm -f *_sub.* *_type.sh
  rm -f *_dae*.* *_cse.* *_ode.*
  rm -f *_obs.* *_rfe.* *_ss.*
  rm -f *_dm.* *_csm.*  *_tf.* *_sr*.* *_ir*.* *_*fr.*
  rm -f *_numpar.m *_numpar.c *_input.m *_input.c *_switch.c *_switch.txt
  rm -f *_sm.* *_can.*
  rm -f *_struc.* *_sympar.txt *_sympar.c *_sympar.h *_sympar.m
  rm -f *_odes.c *_odes.dat *_odes.gdat *_odes.m *_odes.ps
  rm -f *_odeso.dat *_odeso.gdat *_odeso.sdat *_odeso.m *_odeso.ps
  rm -f *_*.doc *_*.idx *_*.ind *_*.ilg *_*.dvi *_*.aux *_*.lof *_*.toc
  rm -f *_rep.tex
  rm -f  *_unique_raw_list *_raw_list
  rm -f mtt_error.txt mtt_info.txt *_ode2odes.out 
  rm -f *_*_write.r *_simpar.m *_simpar.p
  rm -f *_cseo.oct *_input.oct *_simpar.oct *_smxax.oct
  rm -f *_csex.oct *_numpar.oct *_smxa.oct *_state.oct 
  rm -f *_ode.oct *_odeo.oct
  rm -f *_cseo.cc *_input.cc *_simpar.cc *_smxax.cc
  rm -f *_csex.cc *_numpar.cc *_smxa.cc *_state.cc 
  rm -f *_ode.cc *_odeo.cc
  rm -f *_logic.m *_logic.cc *_logic.oct
  rm -f *_state.m *_state.cc *_state.oct
  rm -f *_ode2odes.* *.dat2
  rm -fR *_rep MTT_work
  exit
fi

# Clean up named system
if [ "$2" = "Clean" ] && [ "$3" = "" ]; then
  echo 'Removing all generated files for system ' $1
  rm -f *.log  mtt_info.txt warning.txt
  rm -f $1_abg.ps $1_args.*  $1_cr.txt $1_abg.tex
  rm -f $1_sabg.fig $1_sabg.ps $1_head.fig $1_bnd.fig 
  rm -f $1_sympar.r $1_sympar.c $1_sympar.h $1_sympar.txt? $1_sympar.tex
  rm -f $1_rbg.* $1_cmp.* $1_fig.fig $1*_*cbg.* $1*_ese.* $1_def.* $1_alias.*
  rm -f $1_sub.* $1_type.sh
  rm -f $1_dae*.* $1_cse.* $1_ode.*  $1_obs.* $1_rfe.* $1_ss.*
  rm -f $1_dm.* $1_csm.* $1_tf.* $1_sr*.* $1_ir*.* $1_*fr.*
  rm -f  $1_numpar.m $1_numpar.c $1_input.m $1_input.c $1_switch.c $1_switch.txt
  rm -f $1_sm*.* $1_can.*
  rm -f $1_struc.* $1_sympar.txt $1_sympar.c $1_sympar.h $1_sympar.m
  rm -f $1_odes.c $1_odes.dat $1_odes.gdat $1_odes.sdat $1_odes.m $1_odes.ps
  rm -f $1_odeso.dat $1_odeso.gdat $1_odeso.m $1_odeso.ps
  rm -f $1_*.doc $1_*.idx $1_*.ind $1_*.ilg $1_*.dvi $1_*.aux $1_*.lof $1_*.toc
  rm -f $1_rep.tex
  rm -f $1_unique_raw_list $1_raw_list
  rm -f mtt_error.txt mtt_info.txt $1_ode2odes.out 
  rm -f $1_*_write.r $1_simpar.m $1_simpar.p
  rm -f $1_cseo.oct $1_input.oct $1_simpar.oct $1_smxax.oct
  rm -f $1_csex.oct $1_numpar.oct $1_smxa.oct $1_state.oct 
  rm -f $1_ode.oct $1_odeo.oct
  rm -f $1_cseo.cc $1_input.cc $1_simpar.cc $1_smxax.cc
  rm -f $1_csex.cc $1_numpar.cc $1_smxa.cc $1_state.cc 
  rm -f $1_ode.cc $1_odeo.cc
  rm -f $1_logic.m $1_logic.cc $1_logic.oct 
  rm -f $1_state.m $1_state.cc $1_state.oct
  rm -f $1_ode2odes.* $1.dat2
  rm -fR $1_rep MTT_work
  exit
fi

if [ "$2" = "rep" ]; then
     documenttype=article
      # See if we are making a book -- ie representation rep on a directory
     isMTT_work=`pwd | grep 'MTT_work'`
      if [ -n "$isMTT_work" ]; then
	dotdot='../'
      fi  
  
     #isdirectory=`file $dotdot$1 | awk '{print $2}' | grep directory`
     if [ -d "$dotdot$1" ]; then
	documenttype=book
     fi
else
     documenttype=section
fi

case $2 in
    nyfr)
	NyquistStyle='True'
	;;
    nifr)
	NyquistStyle='True'
	;;
    *)
	
esac

#SUMMARY abg*	acausal bond graph (fig)
#SUMMARY abg*	acausal bond graph (ps)
#SUMMARY abg*	acausal bond graph (view)
# Invoke explicit requests for modification
if [ "$2" = "abg" ] && [ "$3" = "fig" ]; then
  mtt_check_var "$FIG" FIG
  echo Editing $1_$2.$3
  ($FIG $1_$2.$3; cp $1_abg.fig $1_$1_abg.fig) &
  exit
fi

# Rename a system
if [ "$1" = "rename" ]; then
  mtt_rename_all $2 $3
  exit
fi

# Copy systems from the example library
if [ "$1" = "copy" ]; then
   #set up source and destination dirs
    source=$3
    if [ -z "$source" ]; then
      source=$MTT_Examples
    fi
    destination=$4
    if [ -z "$destination" ]; then
      destination=$2
    fi      
# check that its not here already
  file_exists=`ls $destination/$2_abg.fig 2> /dev/null`
  if [ -n "$file_exists" ]; then
    if [ "$quiet" != "quiet" ]; then    
      echo System $2 exists already - no action taken
    fi
  else
    source=$3
    if [ -z "$source" ]; then
      source=$MTT_EXAMPLES
    fi
    destination=$4
    if [ -z "$destination" ]; then
      destination=$2
    fi    
echo Copying system $2 from $source into directory $destination
    find $source -name "$2" -exec cp -rf {} . \; 
  fi
  exit
fi

# Copy components from the library
if [ "$1" = "compcopy" ]; then

   #Pull out the base name (we may have a library as well)
   name=`basename $2`

   #set up source and destination dirs
    source=$3
    if [ -z "$source" ]; then
      source=$MTT_COMPONENTS
    fi
    destination=$4
    if [ -z "$destination" ]; then
      destination='.'
    fi   

  # check that its not here already
  file_exists=`ls $destination/"$name"_abg.fig 2> /dev/null`
  if [ -n "$file_exists" ]; then
    if [ "$quiet" != "quiet" ]; then    
      echo Component $name exists already - no action taken
    fi
  else
    if [ $source = "." ]; then
      cp -u *_*.* $destination
    else
      comp_path=`mtt_find $source $2 path_only`
      n_found=`echo $comp_path | wc | awk '{print $2}'`

      if [ "$n_found" = "1" ]; then
         echo Copying $2 from $comp_path to $destination
         cp $comp_path/*_*.* $destination
         exit 0
      elif [ "$n_found" = "0" ]; then
         echo Component $2 not found - is MTT_COMPONENTS set correctly?
         exit 1
      elif [ "$n_found" > "1" ]; then
         echo "Multiple versions of $2 found (see below) - use a more explicit alias"
         mtt -q find $2
         exit 2
      fi
    fi
  fi
  exit
fi

# Copy CRs from the library
if [ "$1" = "crcopy" ]; then
  # check that its not here already (or a _cr.r version)
  file_exists=`ls $2.cr $2_cr.r 2> /dev/null`
  if [ -n "$file_exists" ]; then
    if [ "$quiet" != "quiet" ]; then    
      echo $2.cr or $2_cr.r exists already - no action taken
    fi
  else
    path_name=$3
    if [ -z "$path_name" ]; then
      path_name=$MTT_LIB/cr/r
    fi
    echo Copying CR $2 to here from $3
    find $path_name -name "$2.cr" -exec cp {} . \;
  fi
  exit
fi


# Version control
VC=''

if [ "$3" = "vc" ]; then
  tidy=untidy;
  if [ -n "$4" ]; then
    log_message=$4
  else
    log_message="No Message"
  fi
  case $2 in
	abg )
		VC='ok'
		VCext='fig' ;;
	lbl )
		VC='ok'
		VCext='txt' ;;
	desc )
		VC='ok'
		VCext='tex' ;;
	simp )
		VC='ok'
		VCext='r' ;;
	rep )
		VC='ok'
		VCext='txt' ;;
	numpar )
		VC='ok'
		VCext='txt' ;;
	input )
		VC='ok'
		VCext='txt' ;;
	state )
		VC='ok'
		VCext='txt' ;;
	odes )
		VC='ok'
		VCext='h' ;;
	sspar )
		VC='ok'
		VCext='r' ;;
	*)
		echo Version control is not appropriate for representation $2
		exit  ;;
  esac
fi

# Classify the representation - needed for conversion route to postscript
PLOTTYPE='single';
case $2 in
	abg )
		REPTYPE='bg' ;;
	sabg )
		REPTYPE='bg' ;;
	cbg )
		REPTYPE='bg' ;;
    	input )
		REPTYPE='txt' ;;
	numpar )
		REPTYPE='txt' ;;
	state )
		REPTYPE='txt' ;;
	simpar )
		REPTYPE='txt' ;;
	obspar )
		REPTYPE='txt' ;;
	odes)
		REPTYPE='data'; PLOTTYPE='multiple' ;;
	odeso)
		REPTYPE='data'; PLOTTYPE='multiple' ;;
	sms)
		REPTYPE='data'; PLOTTYPE='multiple' ;;
	smso)
		REPTYPE='data'; PLOTTYPE='multiple' ;;
	odess)
		REPTYPE='data' ;;
	odesso)
		REPTYPE='data' ;;
	daes)
		REPTYPE='data'; PLOTTYPE='multiple' ;;
	daeso)
		REPTYPE='data'; PLOTTYPE='multiple' ;;
	ir)
		REPTYPE='data' ;;
	iro)
		REPTYPE='data' ;;
	sr)
		REPTYPE='data' ;;
	sro)
		REPTYPE='data' ;;
	lmfr)
		REPTYPE='data' ;;
	lpfr)
		REPTYPE='data' ;;
	nyfr)
		REPTYPE='data' ;;
	nifr)
		REPTYPE='data' ;;
	*)
		REPTYPE='tex' ;;
esac


## Set up the main arguments
sys=$1
rep=$2
lang=$3

## Make ps pdf if -pdf set
if [ "$lang" = "ps" ]; then
  lang=$ps
fi


# Create some strings
Subsystem=$1$subsystem;

Subsystem_=$Subsystem"_"
Subsystem_ese=$Subsystem"_ese"
Subsystem_def=$Subsystem"_def"
Subsystem_rdae=$Subsystem"_rdae"
Subsystem_dae=$Subsystem"_dae"
Subsystem_subs=$Subsystem"_subs"
Subsystem_cr=$Subsystem"_cr"
Subsystem_cbg=$Subsystem"_cbg"

## Create the make target name
target=${sys}_${rep}.${lang}

## Arguments
ARGS=$4; _ARGS=-$4; __ARGS=`echo $_ARGS | tr ',' '-'`

# Save up the argument list in a file; but only if argument has changed
#DIFF doesn't like empty files - so put a blank if empty
#if [ -z "$ARGS" ]; then
#  ARGS=' ';
#  _ARGS='';
#fi

#cat > $1_args.new <<EOF
#$ARGS
##EOF

#DIFF=`diff -bq $1_args.m $1_args.new 2>/dev/null`

#if [ -n "$DIFF" ]; then
#  mv $1_args.new $1_args.m
#fi

# Tidy mode - operate in the directory MTT-work
if [ "$tidy" = "tidy" ]; then
   mkdir -p MTT_work
   cp -p -u  Makefile Make *.* .* MTT_work  2>/dev/null
   cd MTT_work

   if [ -f ".octaverc" ]; then
     touch .octaverc
   else
     echo Copying .octaverc 
     cp $MTT_LIB/octave/.octaverc .
   fi

   if [ -f "useful-functions.hh" ]; then
     touch useful-functions.hh
   else
     echo Copying useful-functions.hh
     cp $MTT_CC/include/useful-functions.hh .
   fi

   if [ -z "$directory" ]; then
     Directory=''
   else
     Directory=$directory/MTT_work
   fi

     mtt -u -q  $mtt_switches -S "$Directory"  $1 $2 $3 $4
     mtt_status=$?

   # Exit on failure
   if [ "$mtt_status" != "0" ]; then
     echo Exiting MTT with error $mtt_status
     exit 1
   fi

  # Copy back form working directory
   if [ "$3" != "view" ] && [ "$3" != "hview" ] && [ -z "$reset" ]; then
      if [ "$3" = "html" ]; then
	  echo Moving $1_$2
          mv $1_$2 ..
      else
        if [ "$PLOTTYPE" = "multiple" ]; then
          echo Copying  $1_$2$__ARGS.$ps
          cp  $1_$2$__ARGS.$ps ..
        else
          echo Copying  $1$subsystem"_"$2.$lang
          cp  -p -u $1$subsystem"_"$2.$lang ..
        fi
      fi
    fi

   # Remove the MTT_work directory if very tidy
   if [ "$verytidy" = "verytidy" ]; then
    echo Removing all working files
    rm -rf ../MTT_work
  fi
exit
fi 

# User defined representations
## Copy from library if not already here
if [ -f "$MTT_REP/$2_rep.make" ]; then
  if [ -f "$2_rep.make" ]; then
    echo Using $2_rep.make
  else
    echo Copying $2_rep.make from $MTT_REP
    cp $MTT_REP/$2_rep.make .
  fi
fi

if [ -f "$2_rep.make" ]; then
   if [ -n "$4" ]; then
      filename=$1_$2-$4.$3
   else
      filename=$1_$2.$3
   fi
    
   if [ -f "$filename" ]; then
      echo $filename exists
   else
     if [ -n "$Verbose" ]; then
      echo make -s -f $2_rep.make "SYS=$1" "LANG=$3" "ARG=$4" 
     fi
      make -s -f $2_rep.make "SYS=$1" "LANG=$3" "ARG=$4"
      if [ -n "$4" ]; then
         echo Copying  $1_$2$__ARGS.$ps
         cp  $1_$2$__ARGS.$ps ..
      fi
   fi
    exit
fi

## Check for pre version 4.0 integration method specification.
if [ $level = "0" ]; then
  if [ -f "$1_simpar.txt" ]; then
    method_line=`grep -i METHOD  $1_simpar.txt`
    if [ -n "`echo $method_line | grep -i euler`" ]; then
      echo Obsolete $1_simpar.txt contains: $method_line
      echo "    please use mtt -i euler in future"
      mtt_switches="$mtt_switches -i euler";
    elif [ -n "`echo $method_line | grep -i implicit`" ]; then
      echo Obsolete $1_simpar.txt contains: $method_line
      echo "    please use mtt -i implicit in future"
      mtt_switches="$mtt_switches -i implicit";
    fi
  fi
fi

if [ -n "$reset" ]; then
  if [ -f "$1_$2.$3" ]; then
    echo Resetting time stamp on $1_$2.$3
    touch $1_$2.$3
  else
    echo $1_$2.$3 does not exist - no action taken
  fi
  exit;    
fi


if [ -n "$sensitivity" ]; then
  sys=`echo $1 | cut -c 2-`
  sys_abg=$sys"_abg"
fi

################################
# This is the main mtt programme
################################


##echo Target is $target, Subsystem is $Subsystem, options are $mtt_switches
$MAKE -S $verbose  -f  -  $target << EOF

# Cancel implicit rules I don't want
%.dvi: %.tex

# MTT implicit rules
## .oct files
ifneq ($2,ode2odes)
%.oct:  %.cc $1_def.h $1_sympar.h $1_cr.h
	echo Creating $1_$2.oct; $MKOCTFILE  $< 
endif


## .cc files
.PRECIOUS: %.cc # Don't let mtt delete them
ifneq ($2,ode2odes)
%.cc:  %.m
	mtt_m2cc.sh  $1 $2 cat 
endif

# Generates code to write reduce code
$1_ode_write.r: $1_def.m
	def2write_r  $1 $2

ifeq ("$sensitivity","sensitivity")
ifeq ("$level","0")
$1_abg.fig: $sys_abg.fig
	abg2sensitivity_fig $sys
else # Either find the sensitivity model or fetch the model and create sensitivity model
$1_abg.fig:
	mtt -q -u $mtt_switches compcopy $1 || abg2sensitivity_fig $sys
endif
endif

ifneq ("$sensitivity","sensitivity")
ifneq ("$level","0")
# If level>0, try and get subsystem files; creating if necessary
$1_abg.fig:
	mtt -q -u $mtt_switches compcopy $1
endif
endif

# Create an arg file if it doesn't exist
$1_args.m:
	touch $1_args.m

#Create skeleton files (with titles) if not already there
#SUMMARY lbl*	label file (txt)
#SUMMARY lbl	label file (txt)
#SUMMARY lbl*	label file (view)
#SUMMARY lbl	label file (view)
#SUMMARY lbl*	label file (tex)
#SUMMARY lbl	label file (tex)
$1_lbl.txt:
	abg2lbl_fig2txt $1 $sensitivity

$1_lbl.tex: $1_lbl.txt
	lbl_txt2tex $1

#SUMMARY alias  name aliases for each subsystem (txt)
$1_alias.txt: $1_lbl.txt
	lbl2alias_txt2txt $1

#SUMMARY alias  name aliases for each subsystem (m)
$1_alias.m: $1_alias.txt
	alias_txt2m $1

#SUMMARY cr	constitutive relationship for each subsystem (txt)
$1_cr.txt: $1_abg.m $1_sub.sh
	abg2cr_m2txt $1
 
	if [ "$level" = "0" ]; then \
	  mv $1_cr.txt MTT_cr.txt; \
	else \
	  cat $1_cr.txt >> MTT_cr.txt; \
	fi

	sh $1_sub.sh "rm -f " '_cr.txt' # Remove the txt.cr files
	sh $1_sub.sh "mtt $mtt_switches -q -u -l $level+1 " ' cr txt' #Create new ones
 
 
	if [ "$level" = "0" ]; then \
	  sort -u MTT_cr.txt> $1_cr.txt; \
	fi

#SUMMARY cr	constitutive relationship for each subsystem (r)
$1_cr.r: $1_cr.txt
	cr_txt2r $1

#SUMMARY cr	constitutive relationship header (c)
$1_cr.h: 
	echo Creating $1_cr.h
	echo "// CR headers for system $1" > $1_cr.h

# Cheat a bit and use the top level cr file for the subsystem as well
ifneq ($sub,)
$Subsystem_cr.r: $1_cr.r
	echo Creating $Subsystem_cr.r "(copying $1_cr.r)"
	cp $1_cr.r $Subsystem_cr.r
endif
#SUMMARY cr	constitutive relationship for each subsystem (tex)
#SUMMARY cr	constitutive relationship for each subsystem (view)
$1_cr.tex: $1_cr.r
	txt2tex $1 cr r

#SUMMARY sympar	symbolic parameters (txt)
#SUMMARY sympar*	symbolic parameters (view)
$1_sympar.txt: $1_type.sh $1_abg.m $1_aliased.txt
	mtt_make_sympar $1

#SUMMARY sympar	symbolic parameters (r)
$1_sympar.r: $1_sympar.txt
	sympar_txt2r $1
$1_sympar.m: $1_sympar.txt
	sympar_txt2m $1
$1_sympar.h: $1_sympar.txt
	sympar_txt2h.sh $1

#SUMMARY sympar	symbolic parameters (c)
# txt to c sympar conversion
$1_sympar.c: $1_sympar.txt
	sympar_txt2c $1

#SUMMARY sympar	symbolic parameters (tex)
# txt to tex (LaTeX) sympar conversion
$1_sympar.tex: $1_sympar.txt
	sympar_txt2tex $1

#SUMMARY logic	Dynamic switch logic (tex)
#SUMMARY logic	Dynamic switch logic (view)
$1_logic.tex: $1_logic.txt
	txt2tex $1 logic txt


#SUMMARY switch	Dynamic switch information (txt)
$1_switch.txt: $1_struc.txt
	struc2switch_txt $1
#$1_switchopen.m: $1_switch.txt $1_sympars.txt $1_logic.txt
#	switch_txt2m $1

#SUMMARY sympars sympar + dynamic switch information (txt)
$1_sympars.txt: $1_sympar.txt $1_switch.txt
	   echo Creating $1_sympars.txt
	   cat $1_sympar.txt $1_switch.txt > $1_sympars.txt

#SUMMARY simp	simplification information (r)
$1_simp.r:
	echo Creating $1_simp.r
	( \
	echo "%% Reduce commands to simplify output for system $1 ($1_simp.r)"; \
	cat $MTTPATH/trans/m/rcs_header.txt; \
	    echo 'ON ALLFAC; %Multiplicative factors'; \
	    echo 'OFF DIV; %Polynomial division'; \
	    echo 'OFF FACTOR; %Factorise polynomials'; \
	    echo 'OFF LIST; %Each term on a new line'; \
	echo 'END;'; \
	)> $1_simp.r

#SUMMARY subs  algebraic substitution (r)
$Subsystem_subs.r: 
	mtt $mtt_switches -q -u $1 sympar txt; 
	makesubs $Subsystem;

#SUMMARY obspar  GPC observability function parameters (r)
$1_obspar.r:
	echo Creating $1_obspar.r
	( \
	echo "%% Reduce  GPC observability function parameters for system $1 ($1_obspar.r)"; \
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo 'MTTGPCNy := 5;'; \
	echo 'MTTGPCNu := 0;'; \
	echo 'Matrix MTTdU(5,1);'; \
	echo 'MTTdU(1,1) := MTTdU1;'; \
	echo 'MTTdU(2,1) := MTTdU2;'; \
	echo 'MTTdU(3,1) := MTTdU3;'; \
	echo 'MTTdU(4,1) := MTTdU4;'; \
	echo 'MTTdU(5,1) := MTTdU5;'; \
	echo 'Matrix MTTUU(1,5);'; \
	echo 'MTTUU(1,1) := MTTu1;'; \
	echo 'MTTUU(1,2) := MTTu11;'; \
	echo 'MTTUU(1,3) := MTTu12;'; \
	echo 'MTTUU(1,4) := MTTu13;'; \
	echo 'MTTUU(1,5) := MTTu14;'; \
	echo 'END;'; \
	)> $1_obspar.r

#SUMMARY simpar	simulation information (txt)
$1_simpar.txt:
	echo Creating $1_simpar.txt
	( \
	echo '# -*-octave-*- Put Emacs into octave-mode'; \
	echo "# Simulation parameters for system $1 ($1_simpar.txt)"; \
	echo "# Generated by MTT on" `date`.; \
	cat $MTTPATH/trans/rcs_header.sh; \
	echo ;\
	echo 'FIRST        = 0.0;       # First time in simulation output'; \
	echo 'DT          = 0.1;        # Print interval'; \
	echo 'LAST        = 10.0;       # Last time in simulation'; \
	echo 'STEPFACTOR  = 1;          # Integration steps per print interval'; \
	echo 'WMIN        = -1;         # Minimum frequency = 10^WMIN'; \
	echo 'WMAX        = 2;          # Maximum frequency = 10^WMAX'; \
	echo 'WSTEPS      = 100;        # Number of frequency steps'; \
	echo 'INPUT       = 1;          # Index of the input'; \
	)> $1_simpar.txt

#SUMMARY simpar	simulation information (m)
$1_simpar.m: $1_simpar.txt $1_def.r $1_sympar.txt
	mtt_txt2m $1 simpar


#SUMMARY numpar	numerical parameter declaration -- default (txt) 
$1_numpar.txt : FORCE
	mtt -q $1 sympar txt
	mtt -q $1 def r
ifeq ($target,$1_numpar.txt)
	mtt_update $1 numpar update
else
	mtt_update $1 numpar
endif

#SUMMARY state	numerical state declaration  -- default (txt)
$1_state.txt : FORCE
	mtt -q $1 struc txt
	mtt -q $1 sympar txt
ifeq ($target,$1_state.txt)
	mtt_update $1 state update
else
	mtt_update $1 state
endif

#SUMMARY state	numerical state declaration  -- default (txt)
$1_input.txt : FORCE
	mtt -q $1 struc txt
	mtt -q $1 sympar txt
ifeq ($target,$1_input.txt)
	mtt_update $1 input update
else
	mtt_update $1 input
endif

#SUMMARY logic	Dynamic switch logic (txt)
$1_logic.txt : FORCE
	mtt -q $1 def r
	mtt -q $1 struc txt
	mtt -q $1 sympar txt
ifeq ($target,$1_logic.txt)
	mtt_update $1 logic update
else
	mtt_update $1 logic
endif

# Dummy target
FORCE:

#SUMMARY numpar	numerical parameter declaration (m) 
$1_numpar.m:  $1_numpar.txt $1_sympars.txt
	mtt_txt2m $1 numpar

#SUMMARY numpar	numerical parameter declaration (c) 
#SUMMARY numpar	numerical parameter declaration (view) 
$1_numpar.c:  $1_numpar.txt $1_sympar.c
	txt2c $1 numpar



#SUMMARY input	numerical input declaration (m) 
$1_input.m:  $1_input.txt $1_sympars.txt
	mtt_txt2m $1 input

#SUMMARY input	numerical input declaration (m) 
$1_logic.m:  $1_logic.txt $1_switch.txt
	mtt_txt2m $1 logic

#SUMMARY state	state declaration  -- default (txt)
#$1_state.txt: 
#	mtt $mtt_switches $1 struc txt; 
#	mtt $mtt_switches $1 ss r; 
#	struc2state_txt2txt $1

#SUMMARY state	state declaration (m) 
$1_state.m:  $1_state.txt $1_sympars.txt
	mtt_txt2m $1 state

#SUMMARY desc Verbal description of system (tex)
$1_desc.tex:
	makedesc $1


#SUMMARY params	symbolic parameter setting (r)
 $1_params.r: 
	echo Creating $1_params.r
	( \
	echo "%% Parameter file for system $1 ($1_params.r)"; \
	echo "%% This file provides symbolic parameters for simplification";\
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo 'END;'; \
	)> $1_params.r


#SUMMARY sspar	steady-state definition (r)
$1_sspar.r: 
	struc2sspar_txt2r $1

#SUMMARY sspar	steady-state parameters (tex)
#SUMMARY sspar	steady-state parameters (view)
$1_sspar.tex: $1_sspar.r
	txt2tex $1 sspar r

#SUMMARY rep*	report (txt)
#SUMMARY rep	report (tex)
#SUMMARY rep*	report (view)
#SUMMARY rep*	report (html)


ifeq ($documenttype,book)
$1_rep.txt:
	dir2rep $1 $dotdot;
else
$1_rep.txt:
	makerep_txt $1;
endif

#SUMMARY rbg	raw bond graph (m)
#Raw bond graph: fig file to mfile
$1_rbg.m: $1_abg.fig $1_lbl.txt
	lbl2component $1 | sh || exit 1 # Grab specified components now
	rbg_fig2m $1
$1_cmp.m: $1_rbg.m
$1_fig.fig: $1_rbg.m

#SUMMARY sabg	stripped acausal bond graph (fig)
#SUMMARY sabg	stripped acausal bond graph (ps)
#SUMMARY sabg	stripped acausal bond graph (view)
$1_sabg.fig: $1_rbg.m


#Subsystem creation commands
#SUMMARY sub Executable subsystem list (sh)
$1_sub.sh: $1_abg.m
	abg2sub_m2sh $1

#SUMMARY sub LaTeX subsystem list (tex)
#SUMMARY sub subsystem list (ps)
#SUMMARY sub subsystem list (view)
$1_sub.tex: $1_sub.sh
ifeq ($documenttype,section)
	sub_sh2tex $1
else
	sub_sh2tex -l $1
endif

#SUMMARY abg	acausal bond graph (m)
#Raw bond graph to acausal bond graph: mfile

ifneq ($start_at_abg,yes)
$1_abg.m: $1_rbg.m $1_alias.m $1_cmp.m 
	cmp2sub_m2sh $1
	(sh $1_sub.sh "mtt $mtt_switches -q -u -l $level+1 " ' abg m null  || exit 1') || exit 1
	rbg2abg_m $info_switch $1
endif

#SUMMARY cbg*	causal bond graph (m)
#Acausal bond graph to causal bond graph: mfile
$1_cbg.m: $1_abg.m
	abg2cbg_m  $info_switch $causality_switch $1

$1_type.sh: $1_cbg.m

#SUMMARY cbg*	causal bond graph (fig)
#SUMMARY cbg*	causal bond graph (ps)
#SUMMARY cbg*	causal bond graph (view)
#Causal bond graph: mfile to fig conversion
$1_cbg.fig: $1_cbg.m  $1_fig.fig $1_type.sh
	sh $1_type.sh 'echo cbg_m2fig ' ' ' ' ' | sh

#SUMMARY ese	elementary system equations (r)
#SUMMARY def	definitions - system orders etc. (r)
#SUMMARY def	definitions - system orders etc. (m)
#SUMMARY def	definitions - system orders etc. (h)
#SUMMARY struc*	structure - list of inputs, outputs and states (txt)
#SUMMARY struc	structure - list of inputs, outputs and states (tex)
#SUMMARY struc*	structure - list of inputs, outputs and states (view)
#Elementary system equations + definitions
${sys}_ese.r: $1_cbg.m 
	   cbg2ese_m2r $partition $info_switch $Subsystem; #ese_tidy $1

$1_def.r: $1_ese.r
	touch $1_def.r
$1_struc.txt: $1_ese.r
	touch $1_struc.txt
$1_aliased.txt: $1_ese.r
	touch $1_aliased.txt
$1_struc.tex: $1_struc.txt
	struc_txt2tex $1
$1_struc.m: $1_struc.txt 
	struc_txt2m $1
$1_def.m: $1_def.r
	def_r2m $1; matlab_tidy $1_def.m;
$1_def.h: $1_def.m
	def_m2h.sh $1

#SUMMARY rdae	raw differential-algebraic equations (r)
#SUMMARY dae	differential-algebraic equations (r)
#SUMMARY dae*	differential-algebraic equations (m)
#SUMMARY dae	differential-algebraic equations (tex)
#SUMMARY dae*	differential-algebraic equations (view)
#SUMMARY dae	differential-algebraic equations (ps)
#Differential-algebraic equations

${sys}_rdae.r: ${sys}_ese.r ${sys}_def.r
ifneq ($partition,)
	echo Doing subsystems
	mtt_make_subsystems  ${sys} rdae r
endif
	ese2rdae_r ${Subsystem}; tidy ${Subsystem}_rdae.r

${sys}_dae.r: ${Subsystem}_rdae.r ${Subsystem}_def.r ${Subsystem}_subs.r ${Subsystem}_cr.r
ifneq ($partition,)
	echo Doing subsystems
	mtt_make_subsystems  ${sys} dae r
endif
ifeq ($rdae_is_dae,1)
	echo Copying $1_rdae.r to $1_dae.r
	cp $1_rdae.r  $1_dae.r
else
	rdae2dae_r ${Subsystem}; tidy ${Subsystem}_dae.r
endif

$1_dae.m: $1_def.r $1_dae.r  $1_sympars.txt
	dae_r2m $1; matlab_tidy $1_dae.m; matlab_tidy $1_daeo.m
$1_dae.c: $1_def.r $1_dae.r  $1_sympar.r
	dae_r2c $1; c_tidy $1_dae.c
$1_dae.tex: $1_dae.r $1_simp.r
	dae_r2tex $partition $1; latex_tidy $1_dae.tex

#SUMMARY cse	constrained-state equations (r)
#SUMMARY cse*	constrained-state equations (m)
#SUMMARY cse*	constrained-state equations (oct)
#SUMMARY cse	constrained-state equations (tex)
#SUMMARY cse*	constrained-state equations (view)
#SUMMARY cse	constrained-state equations (ps)
#Constrained-state equations
${sys}_cse.r: ${Subsystem}_dae.r ${Subsystem}_dae.r ${Subsystem}_def.r ${Subsystem}_subs.r 
ifneq ($partition,)
	echo Doing subsystems
	mtt_make_subsystems  ${sys} cse r
endif
	dae2cse_r $Solve ${Subsystem}; tidy ${Subsystem}_cse.r #$1_subs.r
$1_csex.r: $1_cse.r
	touch $1_csex.r
$1_cseo.r: $1_cse.r
	touch $1_cseo.r

#$1_cse.m: $1_def.r $1_cse.r $1_sympar.r  $1_subs.r 
#	cse_r2m $1; matlab_tidy $1_cse.m
${sys}_cse.m: ${Subsystem}_def.r ${Subsystem}_cse.r ${sys}_sympars.txt
ifneq ($partition,)
	echo Doing subsystems
	mtt_cp_subrep ${sys} sympars txt
	mtt_make_subsystems  ${sys} cse m
endif
	mtt_r2m ${Subsystem} cse;#  matlab_tidy $1_cse.m; matlab_tidy $1_cseo.m; 

${sys}_cseo.m: ${Subsystem}_def.r ${Subsystem}_cseo.r ${sys}_sympars.txt
ifneq ($partition,)
	echo Doing subsystems
	mtt_cp_subrep ${sys} sympars txt
	mtt_make_subsystems  ${sys} cseo m
endif
	mtt_r2m ${Subsystem} cseo

${sys}_csex.m: ${Subsystem}_def.r ${Subsystem}_csex.r ${sys}_sympars.txt
ifneq ($partition,)
	echo Doing subsystems
	mtt_cp_subrep ${sys} sympars txt
	mtt_make_subsystems  ${sys} csex m
endif
	mtt_r2m ${Subsystem} csex

$1_cse.tex: $1_cse.r  $1_sympar.r $1_simp.r
	cse_r2tex $1 $2; latex_tidy $1_cse.tex


#SUMMARY scse	sensitivity constrained-state equations (r)
#SUMMARY scse	sensitivity constrained-state equations (tex)
#SUMMARY scse	sensitivity constrained-state equations (ps)

$1_scse.r: $1_cse.r $1_def.r 
	cse2scse_r  $1 "$4"; tidy $1_scse.r

#$1_cse.m: $1_def.r $1_cse.r $1_sympar.r  $1_subs.r 
#	cse_r2m $1; matlab_tidy $1_cse.m
$1_scse.m: $1_def.m $1_scse.r $1_sympars.txt
	mtt_r2m $optimise  -parameters $1 scse;  
	matlab_tidy $1_scse.m; matlab_tidy $1_scseo.m; 

$1_scse.tex: $1_scse.r  $1_sympar.r $1_simp.r
	cse_r2tex $1 $2; latex_tidy $1_scse.tex


#SUMMARY ode	ordinary differential equations (r)
#SUMMARY ode*	ordinary differential equations (m)
#SUMMARY ode	ordinary differential equations (c)
#SUMMARY ode	ordinary differential equations (tex)
#SUMMARY ode*	ordinary differential equations (view)
#SUMMARY ode	ordinary differential equations (ps)
#SUMMARY ode	ordinary differential equations (oct)
#Ordinary differential equations

ifeq ($dae_is_ode,1)
$1_ode.r: $1_dae.r
	echo Copying $1_dae.r to $1_ode.r
	cp $1_dae.r  $1_ode.r
else
$1_ode.r: $1_cse.r $1_cseo.r $1_def.r $1_sympar.r $1_subs.r
	cse2ode_r $1; tidy $1_ode.r
endif

$1_odeo.r: $1_ode.r
	touch $1_odeo.r

$1_ode.m: $1_def.r $1_ode.r
	mtt_r2m $optimise -parameters $1 ode m; #  matlab_tidy $1_ode.m
$1_odeo.m: $1_def.r $1_odeo.r
	mtt_r2m $1 odeo m

$1_odea.m: $1_ode.m
	touch $1_odea.m

$1_ode.tex: $1_ode.r  $1_sympar.r $1_simp.r
	ode_r2tex $1; latex_tidy $1_ode.tex


$1_lde.r: $1_dae.r
	dae2lde_r $1; tidy $1_lde.r

$1_lde.tex: $1_lde.r  $1_sympar.r $1_simp.r
	lde_r2tex $1; latex_tidy $1_lde.tex

# The main simulation programme
ifeq ($integration_method,implicit)
$1_ode2odes.m : $1_def.r $1_sympars.txt \
                $1_smxa.m $1_smxax.m\
                $1_simpar.m $1_numpar.m $1_state.m $1_input.m \
                $1_csex.m $1_cseo.m  $1_logic.m
ifeq ($using_oct,yes)
	mtt $mtt_switches -q -u $1 smxa oct
	mtt $mtt_switches -q -u $1 smxax oct
	mtt $mtt_switches -q -u $1 simpar oct
	mtt $mtt_switches -q -u $1 numpar oct
	mtt $mtt_switches -q -u $1 state oct
	mtt $mtt_switches -q -u $1 input oct
	mtt $mtt_switches -q -u $1 csex oct
	mtt $mtt_switches -q -u $1 cseo oct
	mtt $mtt_switches -q -u $1 logic oct
	make_ode2odes $1 cc $integration_method
	echo Creating $1_ode2odes.oct
	mkoctfile $1_ode2odes.cc
	touch $1_ode2odes.m # Create a dummy which wont' be used
else
	make_ode2odes $1 m $integration_method
endif
endif
ifeq ($integration_method,euler)
$1_ode2odes.m : $1_def.r $1_sympars.txt\
		$1_simpar.m $1_numpar.m $1_state.m $1_input.m \
		$1_ode.m $1_odeo.m  $1_logic.m
ifeq ($using_oct,yes)
	mtt $mtt_switches -q -u $1 simpar oct
	mtt $mtt_switches -q -u $1 numpar oct
	mtt $mtt_switches -q -u $1 state oct
	mtt $mtt_switches -q -u $1 input oct
	mtt $mtt_switches -q -u $1 ode oct
	mtt $mtt_switches -q -u $1 odeo oct
	mtt $mtt_switches -q -u $1 logic oct
	make_ode2odes $1 cc $integration_method
	echo Creating $1_ode2odes.oct
	mkoctfile $1_ode2odes.cc
	touch $1_ode2odes.m # Create a dummy which wont' be used
else
	make_ode2odes $1 m $integration_method
endif

endif


#Conversion of m to p to c
#SUMMARY ode	ordinary differential equations (c)
#SUMMARY ode	ordinary differential equations (p)
#SUMMARY state	state declaration (c) 
#SUMMARY state	state declaration (p) 
$1_simpar.p : $1_def.r $1_simpar.m
	mtt_m2p $1_simpar.m
$1_numpar.p : $1_def.r $1_numpar.m
	mtt_m2p $1_numpar.m
$1_state.p : $1_def.r $1_state.m
	mtt_m2p $1_state.m

ifeq ($stdin,stdin)
$1_input.p : $1_def.r
	make_stdin $1 p
else
$1_input.p : $1_def.r $1_input.m
	mtt_m2p $1_input.m
endif

$1_ode.p : $1_def.r $1_ode.m
	mtt_m2p $1_ode.m
$1_odeo.p : $1_def.r $1_odeo.m
	mtt_m2p $1_odeo.m
$1_csex.p : $1_def.r $1_cse.m
	mtt_m2p $1_csex.m
$1_cseo.p : $1_def.r $1_cseo.m
	mtt_m2p $1_cseo.m
$1_smx.p : $1_def.r $1_smx.m
	mtt_m2p $1_smx.m
$1_smxa.p : $1_def.r $1_smxa.m
	mtt_m2p $1_smxa.m
$1_smxax.p : $1_def.r $1_smxax.m
	mtt_m2p $1_smxax.m
$1_logic.p : $1_def.r $1_logic.m
	mtt_m2p $1_logic.m

ifeq ($integration_method,implicit)
$1_ode2odes.p : $1_ode2odes.m $1_def.r $1_smxa.p $1_smxax.p\
		$1_simpar.p $1_numpar.p $1_state.p $1_input.p \
		$1_csex.p $1_cseo.p  $1_logic.p
	mtt_m2p $1_ode2odes.m $integration_method $stdin
endif
ifeq ($integration_method,euler)
$1_ode2odes.p : $1_ode2odes.m $1_def.r\
		$1_simpar.p $1_numpar.p $1_state.p $1_input.p \
		$1_ode.p $1_odeo.p  $1_logic.p
	mtt_m2p $1_ode2odes.m $integration_method $stdin
endif

$1_ode2odes.c: $1_ode2odes.p 
	mtt_p2c $info_switch $1 ode2odes

#SUMMARY sim Octave simulation function (m)

ifeq ($computation,octave)
$1_sim.m: $1_def.r $1_sympar.txt $1_cse.m $1_cseo.m $1_smxa.m $1_smxax.m $1_numpar.m $1_state.m
	mtt_make_sim $1 $integration_method $computation 
endif

ifeq ($computation,c)
$1_sim.m: $1_def.r $1_sympar.txt $1_ode2odes.out $1_numpar.m $1_state.m
	mtt_make_sim $1 $integration_method $computation 
endif

#SUMMARY obs	observer equations for CGPC (r)
#SUMMARY obs*	observer equations for CGPC (m)
#SUMMARY obs	observer equations for CGPC (tex)
#SUMMARY obs*	observer equations for CGPC (view)
#SUMMARY obs	observer equations for CGPC (ps)
#Observer functions for GPC
$1_obs.r: $1_ode.r $1_def.r $1_obspar.r $1_subs.r
	ode2obs_r $1; tidy $1_obs.r
$1_obs.m: $1_def.r $1_sympars.txt $1_obs.r $1_obspar.r $1_numpar.m
	mtt_r2m $optimise  -parameters $1 obs
$1_obs.tex: $1_obs.r  $1_sympar.r $1_simp.r
	obs_r2tex $1; latex_tidy $1_obs.tex


#SUMMARY rfe	robot-form equations (r)
#SUMMARY rfe	robot-form equations (tex)
#SUMMARY rfe*	robot-form equations (view)
#SUMMARY rfe	robot-form equations (ps)
#Robot-form equations
$1_rfe.r: $1_cse.r $1_csm.r $1_def.r $1_sympar.r
	cse2rfe_r $1; tidy $1_rfe.r
$1_rfe.tex: $1_rfe.r  $1_sympar.r  $1_simp.r
	rfe_r2tex $1; latex_tidy $1_rfe.tex

#SUMMARY ss	steady-state equations (r)
#SUMMARY ss*	steady-state equations (m)
#SUMMARY ss	steady-state equations (tex)
#SUMMARY ss*	steady-state equations (view)
#SUMMARY ss	steady-state equations (ps)
#Steady-states
$1_ss.r: $1_def.r $1_sspar.r $1_cr.r $1_ode.r
	sspar2ss_r $1; tidy $1_ss.r
$1_ss.m: $1_def.r  $1_ss.r  $1_numpar.m
	ss_r2m $1; matlab_tidy $1_ss.m
$1_ss.tex: $1_def.r $1_ss.r $1_simp.r
	ss_r2tex $1; latex_tidy $1_ss.tex 


#SUMMARY dm	descriptor matrices (r)
#SUMMARY dm*	descriptor matrices (m)
#SUMMARY dm	descriptor matrices (tex)
#SUMMARY dm*	descriptor matrices (view)
#SUMMARY dm	descriptor matrices (ps)
#Linearised system: descriptor matrices
$1_dm.r: $1_dae.r $1_def.r $1_cr.r  $1_ss.r $1_sympar.r
	dae2dm_r $1; tidy $1_dm.r
$1_dm.m: $1_def.r $1_dm.r $1_sympars.txt
		mtt_r2m $optimise -parameters $1 dm
$1_dm.tex: $1_dm.r $1_sympar.r $1_simp.r 
	dm_r2tex $1; latex_tidy $1_dm.tex



#SUMMARY csm	constrained-state matrices (r)
#SUMMARY csm	constrained-state matrices (m)
#SUMMARY csm	constrained-state matrices (tex)
#SUMMARY csm	constrained-state matrices (view)
#SUMMARY csm    constrained-state matrices (ps)
#Linearised system: constrained-state matrices
$1_csm.r: $1_cse.r $1_def.r $1_cr.r $1_sspar.r
	cse2csm_r $1 csm; tidy $1_csm.r
$1_csm.m: $1_def.r $1_csm.r $1_sympars.txt
		mtt_r2m $optimise  -parameters $1 csm;  matlab_tidy $1_csm.m
$1_csm.tex: $1_csm.r  $1_sympar.r $1_simp.r
	csm_r2tex $1 csm; latex_tidy $1_csm.tex
#SUMMARY scsm	sensitivity constrained-state matrices (r)
#SUMMARY scsm	sensitivity constrained-state matrices (m)
#SUMMARY scsm	sensitivity constrained-state matrices (tex)
#SUMMARY scsm	sensitivity constrained-state matrices (view)
#SUMMARY scsm	sensitivity constrained-state matrices (ps)
#Linearised system: sensitivity constrained-state matrices
$1_scsm.r: $1_scse.r $1_def.r $1_cr.r $1_sympar.r $1_sspar.r
	cse2csm_r $1 scsm; tidy $1_scsm.r
$1_scsm.m: $1_def.r $1_scsm.r $1_sympars.txt
		csm_r2m $1 scsm;  matlab_tidy $1_scsm.m
$1_scsm.tex: $1_scsm.r  $1_sympar.r $1_simp.r
	csm_r2tex $1 scsm; latex_tidy $1_scsm.tex

#SUMMARY sm	state matrices (r)
#SUMMARY sm*	state matrices (m)
#SUMMARY sm	state matrices (icad)
#SUMMARY sm	state matrices (tex)
#SUMMARY sm	state matrices (c)
#SUMMARY sm*	state matrices (view)
#SUMMARY sm	state matrices (ps)
#Linearised system: state matrices
$1_sm.r: $1_csm.r $1_def.r $1_cr.r $1_ss.r $1_sympar.r
	csm2sm_r $1 sm; tidy $1_sm.r
$1_sm.m: $1_def.r $1_sm.r $1_sympars.txt 
		mtt_r2m $optimise  -parameters $1 sm
$1_sm.icad:  $1_sm.m $1_numpar.m
		sm_m2icad $1
$1_sm.c: $1_def.r $1_sm.r $1_sympar.c
		sm_r2c $1
$1_sm.tex: $1_sm.r  $1_sympar.r $1_simp.r
	sm_r2tex $1 sm; latex_tidy $1_sm.tex

#SUMMARY ssm	sensitivity state matrices (r)
#SUMMARY ssm	sensitivity state matrices (icad)
#SUMMARY ssm	sensitivity state matrices (tex)
#SUMMARY ssm	sensitivity state matrices (c)
#SUMMARY ssm	sensitivity state matrices (ps)
#Linearised system: sensitivity state matrices
$1_ssm.r: $1_scsm.r $1_def.r $1_cr.r $1_ss.r $1_sympar.r
	csm2sm_r $1 ssm; tidy $1_ssm.r
$1_ssm.m: $1_def.r $1_ssm.r $1_sympars.txt 
		mtt_r2m $optimise -parameters $1 ssm
$1_ssm.tex: $1_ssm.r  $1_sympar.r $1_simp.r
	sm_r2tex $1 ssm; latex_tidy $1_ssm.tex

#SUMMARY smx	state matrices with variable state x (r)
#SUMMARY smx	state matrices with variable state x (m)
#SUMMARY smxx	Sparse computation of Ax (m)
#SUMMARY smxtx	Sparse computation of ATx (m)
$1_smx.r: $1_def.r $1_def.m $1_ode.r $1_subs.r
		ode2smx_lang $1 r; tidy $1_smx.r

$1_smx.m: $1_def.r $1_def.m $1_cse.r $1_sympars.txt $1_subs.r
		cse2smx_lang $optimise -parameters $1 smx m

$1_smxa.m: $1_def.r $1_def.m $1_cse.r $1_sympars.txt $1_subs.r
		cse2smx_lang $optimise -parameters $matrix_smxa $1 smxa m

$1_smxax.m: $1_def.r $1_def.m $1_cse.r $1_sympars.txt $1_subs.r
		cse2smx_lang $optimise -parameters $1 smxax m

#SUMMARY smc	controller form state matrices etc. - siso only (r)
#SUMMARY smc	controller form state matrices etc. - siso only (tex)
#SUMMARY smc*	controller form state matrices etc. - siso only (m)
#SUMMARY smc*	controller form state matrices etc. - siso only (view)
#SUMMARY smc	controller form state matrices etc. - siso only (ps)
#Linearised system: controller form state matrices etc.
$1_smc.r: $1_sm.r $1_def.r $1_tf.r 
	sm2smc_r $1; tidy $1_smc.r
$1_smc.tex: $1_smc.r  $1_simp.r
	smc_r2tex $1; latex_tidy $1_smc.tex
$1_smc.m: $1_def.r $1_smc.r $1_numpar.m
		smc_r2m $1;  matlab_tidy $1_smc.m

#SUMMARY smo	observer form state matrices etc. - siso only (r)
#SUMMARY smo	observer form state matrices etc. - siso only (tex)
#SUMMARY smo*	observer form state matrices etc. - siso only (m)
#SUMMARY smo*	observer form state matrices etc. - siso only (view)
#SUMMARY smo	observer form state matrices etc. - siso only (ps)
#Linearised system: observer form state matrices etc.
$1_smo.r: $1_sm.r $1_def.r $1_tf.r 
	sm2smo_r $1; tidy $1_smo.r
$1_smo.tex: $1_smo.r  $1_simp.r
	smo_r2tex $1; latex_tidy $1_smo.tex
$1_smo.m: $1_def.r $1_smo.r $1_numpar.m
		smo_r2m $1;  matlab_tidy $1_smo.m

#SUMMARY ssk	State-space controller gain - siso only (r)
#SUMMARY ssk	State-space controller gain - siso only (tex)
#SUMMARY ssk*	State-space controller gain - siso only (m)
#SUMMARY ssk*	State-space controller gain - siso only (view)
#SUMMARY ssk	State-space controller gain - siso only (ps)
#Linearised system: State-space controller gain
$1_ssk.r: $1_def.r $1_smc.r 
	smc2ssk_r $1; tidy $1_ssk.r
$1_ssk.tex: $1_ssk.r  $1_simp.r
	ssk_r2tex $1; latex_tidy $1_ssk.tex
$1_ssk.m: $1_def.r $1_ssk.r $1_numpar.m
		ssk_r2m $1;  matlab_tidy $1_ssk.m

#SUMMARY ssl	State-space observer gain - siso only (r)
#SUMMARY ssl	State-space observer gain - siso only (tex)
#SUMMARY ssl*	State-space observer gain - siso only (m)
#SUMMARY ssl*	State-space observer gain - siso only (view)
#SUMMARY ssl	State-space observer gain - siso only (ps)
#Linearised system: State-space observer gain
$1_ssl.r: $1_def.r $1_smo.r 
	smo2ssl_r $1; tidy $1_ssl.r
$1_ssl.tex: $1_ssl.r  $1_simp.r
	ssl_r2tex $1; latex_tidy $1_ssl.tex
$1_ssl.m: $1_def.r $1_ssl.r $1_numpar.m
		ssl_r2m $1;  matlab_tidy $1_ssl.m

#SUMMARY tf	transfer function (r)
#SUMMARY tf*	transfer function (m)
#SUMMARY tf	transfer function (tex)
#SUMMARY tf*	transfer function (view)
#SUMMARY tf	transfer function (ps)
#Linearised system: transfer function
$1_tf.r: $1_dm.r $1_sympar.r 
	dm2tf_r $1; tidy $1_tf.r
$1_tf.m: $1_def.r $1_sympars.txt $1_tf.r 
	tf_r2m $1; matlab_tidy $1_tf.m
$1_tf.tex: $1_def.r $1_tf.r $1_sympar.r $1_simp.r
	tf_r2tex $1; latex_tidy $1_tf.tex

#SUMMARY pkim	partialyy-known system identification matrix (r)
#SUMMARY pkim	partialyy-known system identification matrix (tex)
#SUMMARY pkim	partialyy-known system identification matrix (view)
#SUMMARY pkim	partialyy-known system identification matrix (ps)
$1_pkim.r: $1_tf.r $1_sympar.r 
	tf2pkim_r $1; tidy $1_pkim.r
$1_pkim.tex: $1_def.r $1_pkim.r $1_simp.r
	pkim_r2tex $1; latex_tidy $1_pkim.tex

#SUMMARY ctf    controller transfer function (r)
#SUMMARY ctf	controller transfer function (m)
#SUMMARY ctf	controller transfer function (tex)
#SUMMARY ctf	controller transfer function (view)
#SUMMARY ctf	controller transfer function (ps)
#Linearised system: transfer function
$1_ctf.r: $1_dm.r $1_ssk.r  $1_ssl.r   $1_sm.r  
	ssk2ctf_r $1; tidy $1_ctf.r
$1_ctf.m: $1_def.r $1_ctf.r 
	ctf_r2m $1; matlab_tidy $1_ctf.m
$1_ctf.tex: $1_def.r $1_ctf.r $1_sympar.r $1_simp.r
	ctf_r2tex $1; latex_tidy $1_ctf.tex

#SUMMARY ir	impulse response - state (m)
#SUMMARY ir	impulse response - state (dat)
#SUMMARY ir	impulse response - state (ps)
#SUMMARY ir	impulse response - state (view)

#SUMMARY iro	impulse response - output (m)
#SUMMARY iro	impulse response - output (dat)
#SUMMARY iro	impulse response - output (ps)
#SUMMARY iro	impulse response - output (view)

#SUMMARY sr	step response - state (m)
#SUMMARY sr	step response - state (dat)
#SUMMARY sr	step response - state (ps)
#SUMMARY sr	step response - state (view)

#SUMMARY sro*	step response - output (m)
#SUMMARY sro	step response - output (dat)
#SUMMARY sro	step response - output (ps)
#SUMMARY sro*	step response - output (view)

#SUMMARY odes	ode solution - state (m)
#SUMMARY odes*	ode solution - state (dat)
#SUMMARY odes*	ode solution - state (ps)
#SUMMARY odes*	ode solution - state (view)

#SUMMARY sms	ode (in state matrix form) solution - state & output (c)

#SUMMARY odeso	ode solution - output (m)
#SUMMARY odeso*	ode solution - output (dat)
#SUMMARY odeso*	ode solution - output for spreadsheet (sdat) 
#SUMMARY odeso	ode solution - output (ps)
#SUMMARY odeso*	ode solution - output (view)

#SUMMARY daes   dae solution - state (m)
#SUMMARY daes	dae solution - state (dat)
#SUMMARY daes	dae solution - state (ps)
#SUMMARY daes	dae solution - state (view)

#SUMMARY daeso  dae solution - output (m)
#SUMMARY daeso	dae solution - output (dat)
#SUMMARY daeso	dae solution - output (ps)
#SUMMARY daeso	dae solution - output (view)

#Time responses
$1_ir.m: $1_sm.m $1_numpar.m $1_def.m $1_simpar.m
	sm2ir_m $1 '$ARGS'
$1_iro.m: $1_ir.m
	touch $1_iro.m
$1_ir.dat: $1_ir.m
	m2dat $1_ir
$1_iro.dat: $1_iro.m
	m2dat $1_iro
$1_sr.m: $1_sm.m $1_numpar.m $1_simpar.m $1_def.m
	sm2sr_m $1 
$1_sr.dat: $1_sr.m
	m2dat $1_sr
$1_sro.m: $1_sr.m
	touch $1_sro.m$
$1_sro.dat: $1_sro.m
	m2dat $1_sro
1_odes.c: $1_ode.c $1_def.r $1_sympar.r
	ode2odes_r2c $1 
$1_sms.c: $1_sm.c $1_def.r $1_sympar.r
	sm2sms_r2c $1

ifeq ($computation,octave)
$1_odes.dat2: $1_ode2odes.m
	time octave_ode2odes $1
endif

ifeq ($computation,c)
$1_ode2odes.out: $1_ode2odes.c
	echo Creating $1_odes.out
	$CC $1_ode2odes.c -lp2c -lm -o $1_ode2odes.out

$1_odes.dat2: $1_ode2odes.out
	echo Creating $1_odes.dat2 using c version
	    time ./$1_ode2odes.out>$1_odes.dat2
endif

ifeq ($computation,cc)
$1_sim.exe: $1_ese.r 
	mtt $mtt_switches -q $1 sim exe

$1_odes.dat2: $1_sim.exe 
	echo Creating $1_odes.dat2 using cc version $ARGS
	    time ./$1_sim.exe $ARGS >$1_odes.dat2
endif


#$1_odeso.m: $1_odes.m
#	touch $1_odeso.m
#$1_smso.m: $1_sms.m
#	touch $1_smso.m
#$1_daes.m: $1_dae.m $1_numpar.m  $1_def.m $1_input.m $1_simpar.m
#	dae2daes_m $1 '$ARGS'
#$1_daeso.m: $1_daes.m
#	touch $1_daeso.m


#Conversion of data files from dat to sdat format
$1_odeso.sdat: $1_odeso.dat $1_struc.txt
	odeso_dat2sdat $1

$1_odes.sdat: $1_odes.dat $1_struc.txt
	odes_dat2sdat $1

#SUMMARY odess	ode numerical steady-states - states (m)
#SUMMARY odess	ode numerical steady-states - states (dat)
#SUMMARY odess	ode numerical steady-states - states (ps)
#SUMMARY odess	ode numerical steady-states - states (view)

#SUMMARY odesso	ode numerical steady-states - outputs (m)
#SUMMARY odesso	ode numerical steady-states - outputs (dat)
#SUMMARY odesso	ode numerical steady-states - outputs (ps)
#SUMMARY odesso	ode numerical steady-states - outputs (view)

#Numerical steady states
$1_odess.dat2: $1_ode.m $1_odeo.m $1_numpar.m  $1_input.m $1_simpar.m
	ode2odess_m2dat2 $1 
#$1_odess.m: $1_ode.m $1_odeo.m $1_numpar.m  $1_input.m $1_simpar.m
#	ode2odess_m $1 
#$1_odesso.m: $1_odess.m
#	touch $1_odesso.m


#SUMMARY fr	frequency response (m)
#SUMMARY fr	frequency response (dat)
#SUMMARY fr	frequency response (ps)
#SUMMARY fr	frequency response (view)

#SUMMARY lmfr	loglog modulus frequency response (m)
#SUMMARY lmfr	loglog modulus frequency response (dat)
#SUMMARY lmfr	loglog modulus frequency response (ps)
#SUMMARY lmfr*	loglog modulus frequency response (view)

#SUMMARY lpfr	semilog phase frequency response (m)
#SUMMARY lpfr	semilog phase frequency response (dat)
#SUMMARY lpfr	semilog phase frequency response (ps)
#SUMMARY lpfr*	semilog phase frequency response (view)

#SUMMARY nyfr	Nyquist style frequency response (m)
#SUMMARY nyfr	Nyquist style frequency response (dat)
#SUMMARY nyfr	Nyquist style frequency response (ps)
#SUMMARY nyfr	Nyquist style frequency response (view)

#SUMMARY nifr	Nichols style frequency response (m)
#SUMMARY nifr	Nichols style frequency response (dat)
#SUMMARY nifr	Nichols style frequency response (ps)
#SUMMARY nifr	Nichols style frequency response (view)


#Frequency responses
$1_fr.m: $1_dm.m $1_numpar.m $1_def.m $1_simpar.m
	dm2fr_m $1 
$1_fr.dat: $1_sr.m
	m2dat $1_fr
$1_lmfr.dat: $1_fr.m
	m2dat $1_lmfr
$1_lpfr.dat: $1_fr.m
	m2dat $1_lpfr
$1_nyfr.dat: $1_fr.m
	m2dat $1_nyfr
$1_nifr.dat: $1_fr.m
	m2dat $1_nifr


ifeq ($REPTYPE,txt)
#Generic conversion of txt files to tex files
$1_$2.tex: $1_$2.txt
	txt2tex $1 $2 txt
 endif

#Conversion of dat2 files  to dat format
$1_odeso.dat: $1_odes.dat2 $1_def.r
	echo Creating $1_odeso.dat
	dat22dat $1 ode so
$1_odes.dat: $1_odes.dat2 $1_def.r
	echo Creating $1_odes.dat
	dat22dat $1 ode s
$1_odesso.dat: $1_odess.dat2 $1_def.r
	echo Creating $1_odesso.dat
	dat22dat $1 odes so
$1_odess.dat: $1_odess.dat2 $1_def.r
	echo Creating $1_odess.dat
	dat22dat $1 odes s

#Generic conversion of data files from dat to (gplot) gdat format 
$1_$2.gdat: $1_$2.dat $1_struc.txt  $1_args.m
	dat2gdat $1 $2 "$ARGS" "$NyquistStyle"

## Conversion of gdat to fig files
ifeq ($REPTYPE,data)
$1_$2.fig: $1_$2.gdat
	gdat2fig $1_$2

ifneq ($ARGS,) ## Multiple plots
	echo Creating $1_$2$__ARGS.fig
	mv $1_$2.fig $1_$2$__ARGS.fig
	rm -f $1_$2.gdat
endif

## Conversion of gdat fig files to ps/pdf
ifeq ($ARGS,) # single plot
$1_$2.$ps : $1_$2.fig
	echo Creating $1_$2.$ps
	fig2dev -L$eps $1_$2.fig > $1_$2.$ps
else ## Multiple plots
$1_$2.$ps : $1_$2.fig
	echo Creating $1_$2$__ARGS.$ps
	fig2dev -L$eps $1_$2$__ARGS.fig > $1_$2$__ARGS.$ps
endif

endif


#Generic conversion of Latex to latex document
mtt.sty:
	echo Copying mtt.sty to here
	cp $MTTPATH/trans/mtt.sty .
$1_$2.doc: $1_$2.tex
	makedoc "$mtt_switches" "$1" "$2" "$3" "$4" "$documenttype" "$ps"


#Create PostScript version of fig files
ifeq ($REPTYPE,bg)
$1_$2.$ps : $1_$2.fig
	echo Creating $1_$2.$ps
	multi_command2 "fig2dev -L$eps" $1 $2.fig $2.$ps | sh
endif


ifeq ($REPTYPE,tex)
#Generic conversion of LaTeX doc to dvi or pdf
$1_$2.$ps: $1_$2.doc
	doc2$ps $1_$2 "$documenttype"
endif


ifeq ($REPTYPE,tex)
#Create html version of dvi file
$1_$2.html: $1_$2.dvi $1_$2.doc
	echo Creating $1_$2/$1_$2.html
	$LATEX2HTML $1_$2.doc>latex2html.log 2>latex2html.log
endif

#Default view
ifeq ($REPTYPE,bg)
$1_$2.view : $Subsystem_$2.pview
endif

ifeq ($REPTYPE,data)
$1_$2.view: $1_$2.$ps
ifeq ($ARGS,) # single plot
	echo Creating view of $1_$2 - $ps file
	$psview $1_$2.$ps&
else
	echo Creating view of $1_$2$__ARGS - $ps file
	$psview $1_$2$__ARGS.$ps&
endif
endif

ifeq ($REPTYPE,tex)
$1_$2.view : $1_$2.pview
endif

ifeq ($REPTYPE,txt)
$1_$2.view : $1_$2.tview
endif

# Hypertext view
$1_$2.hview: $1_$2.html
	$HTMLVIEW $1_$2/$1_$2.html&

#View a ps file
$Subsystem_$2.pview: $1_$2.$ps
	echo Creating view of $Subsystem_$2 - $ps file
	mtt_multi $psview $Subsystem $2 $ps $viewlevel  | sh 

#View a gdat file
$1_$2.dview: $1_$2.gdat
	echo Creating view of $1_$2
	gdat2view $1_$2 '$ARGS'&

#View a tex file
$1_$2.tview: $1_$2.dvi
	echo Creating view of $1_$2
	$DVIVIEW $1_$2.dvi&

#Report generation
$1_rep.make: $1_rep.txt
	rep_txt2make $1 "$mtt_switches"

$1_reps_made:
	rep_txt2sh $1 "$mtt_switches";  touch $1_reps_made

$1_rep.tex: $1_rep.txt $1_reps_made
	rep_txt2tex $1 "$documenttype" "$directory";

#SUMMARY abg Acausal bond graph report (tex)
$1_abg.tex: $1_sub.sh
	abg2tex $pdf $1

#SUMMARY tf Transfer function (mml)
$1_$2.mml: $1_$2.r
	mtt_r2mml $1 $2


# Version control system - uses RCS
RCS:
	echo Creating RCS
	mkdir RCS
$1_$2.vc: RCS 
	echo Version control on $1_$2.$VCext with message: $log_message
	ci -m"$log_message" -I $1_$2.$VCext </dev/tty  ; co -l $1_$2.$VCext 

EOF
# Remember the exit status of make
make_status=$?

# Tidy up.
# echo Removing log files and other garbage
  rm -f  *_unique_raw_list *_raw_list
  rm -f mtt_error.txt mtt_info.txt 
  rm -f  mtt_info.txt warning.txt
#  rm -f *_*.idx *_*.ind *_*.ilg  *_*.lof *_*.toc

# Remove logs if not debugging
if [ "$debug" != "debug" ]; then
  rm -f *.log
else
  echo Debugging - log files retained in LOGFILES  
  mkdir -p LOGFILES
  mv -f *.log LOGFILES
fi

#Print what's going on if in verbose mode
if [ -n "$Verbose" ]; then
    echo Finishing mtt  $mtt_switches  $1 $2 $3 $4 at level $level
fi

if [ "$make_status" != "0" ]; then
    echo Exiting MTT with error $make_status
    exit 1
fi
