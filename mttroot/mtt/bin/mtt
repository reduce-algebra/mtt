#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt

# P.J.Gawthrop Oct 1989, Dec 1989, 1990, 1991, Oct 1993, Dec 1993, Jan 1994, Dec 95
# Copyright (c) P.J.Gawthrop, 1989, 1990, 1991, 1993, 1994, 1995, 1996.

###############################################################
## Version control history
###############################################################
## $Header$
## $Log$
## Revision 1.30  1996/10/01 14:08:05  peterg
## Replaced $() by ``
## Replaced make with gmake
##
# Revision 1.29  1996/10/01  11:04:05  peter
# Changed name of html document.
#
## Revision 1.28  1996/09/13 18:44:11  peter
## Added params dependencies.
##
## Revision 1.27  1996/09/12 19:24:56  peter
## New numpar/params setup.
##
## Revision 1.26  1996/09/10 17:04:47  peter
## Added impulse response (ir) representation.
##
## Revision 1.25  1996/08/30 20:03:45  peter
## Removed dependencies from vc
##
## Revision 1.24  1996/08/30 18:37:17  peter
## inor changes.
##
## Revision 1.23  1996/08/30 11:10:37  peter
## More files in clean up.
##
## Revision 1.22  1996/08/30 10:07:51  peter
## Removed impicit creation of abg.fig file.
##
## Revision 1.21  1996/08/22 12:19:51  peter
## Added various document viewers.
##
## Revision 1.20  1996/08/20 08:24:53  peter
## Now with version control.
##
## Revision 1.19  1996/08/19 15:33:22  peter
## Included new state matric (sm) rep.
## Generate step response (sr) from sm.
##
## Revision 1.18  1996/08/19 13:30:54  peter
## New CLEAN target.
##
## Revision 1.17  1996/08/19 06:48:14  peter
## Explicit figure editing.
##
## Revision 1.16  1996/08/18 19:58:36  peter
## Report generation included.
##
## Revision 1.15  1996/08/18 12:01:01  peter
## Unified format of time responses.
##
## Revision 1.14  1996/08/16 14:52:24  peter
## Added two alternative view options - dview and pview.
##
## Revision 1.13  1996/08/16 08:24:31  peter
## Correctly chooses how to make a ps file using $REPTYPE.
##
## Revision 1.12  1996/08/15 16:47:47  peter
## DAE solution (experimental) included.
##
## Revision 1.11  1996/08/15 11:55:30  peter
## Checks for changed argument.
## Handles frequency response.
##
## Revision 1.10  1996/08/15 07:44:24  peter
## Now handles generic transformations using %.
##
## Revision 1.9  1996/08/14 09:16:08  peter
## Step response now goes through  m, dat and gdat conversions
##
## Revision 1.8  1996/08/12 20:19:52  peter
## Arguments now passed via $1_args.m file
##
## Revision 1.7  1996/08/11 19:49:27  peter
## Parameter passing (via $4) added.
##
## Revision 1.6  1996/08/11 10:40:56  peter
## Added new numpar stuff.
## Added step response.
##
## Revision 1.5  1996/08/10 14:13:47  peter
## Added impulse and frequency response stuff.
##
## Revision 1.4  1996/08/10 09:19:48  peter
## Put in help, info and warranty stuff.
##
## Revision 1.3  1996/08/09 15:13:13  peter
## Generic viewing of any representation via ps files implemented.
##
## Revision 1.2  1996/08/05 19:50:55  peter
## Put in fig.fig target.
##
## Revision 1.1  1996/08/04 17:29:42  peter
## Initial revision
##
###############################################################
echo
echo 'MTT (Model Transformation Tools) version 2.0'
echo 'This is free software with ABSOLUTELY NO WARRANTY.'
echo 'Type `mtt warranty'\' 'for details.'
echo

if [ "$1" = "" ]; then
  echo 'Usage: mtt help'
  echo '       mtt hinfo'
  echo '       mtt info'
  echo '       mtt info topic'
  echo '       mtt manual'
  echo '       mtt warranty'
  echo '       mtt clean'
  echo '       mtt system_name clean'
  echo '       mtt system_name representation vc'
  echo '       mtt system_name representation language'
  echo '       mtt system_name representation language parameters'
  exit
fi


if [ "$1" = "info" ]  && [ "$3" = "" ]; then
  echo Invoking info
  info -f $MTTPATH/doc/mtt.info $2
  exit
fi

if [ "$1" = "hinfo" ] && [$2 = ""]; then
   echo Invoking $HTMLVIEW
   (cd $MTTPATH/doc; $HTMLVIEW ./mtt_toc.html)&
   exit
fi

if [ "$1" = "manual" ] && [$2 = ""]; then
  echo Invoking $DVIVIEW
  $DVIVIEW  $MTTPATH/doc/mtt.dvi &
  exit
fi

if [ "$1" = "warranty" ] && [$2 = ""]; then
  cat << EOF
Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995,1996 Peter J. Gawthrop
This is free software with ABSOLUTELY NO WARRANTY.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

EOF
  exit
fi

# Clean up 
if [ "$1" = "clean" ] && [ "$2" = "" ]; then
  echo 'Removing all generated files for all systems'
  rm -f *.log  mtt_info.txt warning.txt
  rm -f *_abg.m *_args.*
  rm -f *_rbg.* *_cmp.* *_fig.fig *_*cbg.* *_ese.* *_def.* *_sub.sh
  rm -f *_dae*.* *_cse.* *_ode*.* *_obs.* *_rfe.* *_ss.*
  rm -f *_dm.* *_csm.* *_sm.* *_tf.* *_sr*.* *_ir*.* *_*fr.*
  rm -f *_rep.* *_numpar.m
  rm -f mtt_error.txt mtt_info.txt
  exit
fi

# Clean up named system
if [ "$2" = "clean" ] && [ "$3" = "" ]; then
  echo 'Removing all generated files for system ' $1
  rm -f *.log  mtt_info.txt warning.txt
  rm -f $1_abg.m $1_args.* 
  rm -f $1_rbg.* $1_cmp.* $1_fig.fig $1*_*cbg.* $1*_ese.* $1_def.* $1_sub.sh
  rm -f $1_dae*.* $1_cse.* $1_ode*.* $1_obs.* $1_rfe.* $1_ss.*
  rm -f $1_dm.* $1_csm.* $1_sm.* $1_tf.* $1_sr*.* $1_ir*.* $1_*fr.*
  rm -f $1_rep.* $1_numpar.m
  rm -f mtt_error.txt mtt_info.txt
  exit
fi

# Invoke explicit requests for modification
if [ "$2" = "abg" ] && [ "$3" = "fig" ]; then
  echo Editing $1_$2.$3
  $FIG $1_$2.$3 &
  exit
fi


# Save up the argument list in a file; but only if argument has changed
ARGS=$4;
cat > $1_args.new <<EOF
$ARGS
EOF

DIFF=`diff -bq $1_args.m $1_args.new 2>/dev/null`

if [ -n "$DIFF" ]; then
  mv $1_args.new $1_args.m
fi

# Classify the representation - needed for conversion route to postscript
case $2 in
	abg )
		REPTYPE='bg' ;;
	cbg )
		REPTYPE='bg' ;;
	odes)
		REPTYPE='data' ;;
	odeso)
		REPTYPE='data' ;;
	odess)
		REPTYPE='data' ;;
	odesso)
		REPTYPE='data' ;;
	daes)
		REPTYPE='data' ;;
	daeso)
		REPTYPE='data' ;;
	ir)
		REPTYPE='data' ;;
	iro)
		REPTYPE='data' ;;
	sr)
		REPTYPE='data' ;;
	sro)
		REPTYPE='data' ;;
	lmfr)
		REPTYPE='data' ;;
	lpfr)
		REPTYPE='data' ;;
	nyfr)
		REPTYPE='data' ;;
	nifr)
		REPTYPE='data' ;;
	*)
		REPTYPE='tex' ;;
esac


# Version control
VC=''

if [ "$3" = "vc" ]; then
  case $2 in
	abg )
		VC='ok'
		VCext='fig' ;;
	lbl )
		VC='ok'
		VCext='txt' ;;
	 cr)
		VC='ok'
		VCext='r' ;;
	simp )
		VC='ok'
		VCext='r' ;;
	params )
		VC='ok'
		VCext='m' ;;
	input )
		VC='ok'
		VCext='m' ;;
	sspar )
		VC='ok'
		VCext='r' ;;
	*)
		echo Version control is not appropriate for representation $2
		exit  ;;
  esac
fi


# This is the main mtt programme
 
gmake -s  -f -  $1_$2.$3 << EOF

# Cancel implicit rules I don't want
%.dvi: %.tex

# Create an arg file if it doesn't exist
$1_args.m:
	touch $1_args.m


#Create empty files (with titles) if not already there
$1_lbl.txt:
	echo Creating $1_lbl.txt
	( \
	echo "%% Label file for system $1 ($1_lbl.txt)"; \
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo "%% Each line should be of one of the following forms:"; \
	echo "%	a comment (ie starting with %)"; \
	echo "%	Component-name	CR_name	arg1,arg2,..argn"; \
	echo "%	blank"; \
        )> $1_lbl.txt
$1_cr.r:
	makecr $1
$1_simp.r:
	echo Creating $1_simp.r
	( \
	echo "%% Reduce comands to simplify output for system $1 ($1_simp.r)"; \
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo 'END;'; \
        )> $1_simp.r

$1_numpar.m: $1_sympar.r
	sympar2numpar_r2m $1

$1_params.m: 
	echo Creating $1_params.m
	( \
	echo "%% Parameter file for system $1 ($1_params.m)"; \
	echo "%% This file provides the system params for simulation:";\
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo; \
        )> $1_params.m

$1_input.m:
	echo Creating $1_input.m
	( \
	echo "function u = $1_input(t)"; \
	echo "%% Input file for system $1 ($1_input.m)"; \
	echo "%% This file provides the system input for simulation:";\
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo; \
	echo "% Set up system definitions"; \
	echo "[nx,ny,nu,nz,nyz] = $1_def;"; \
	echo "% Change the following lines as you wish"; \
	echo "u = zeros(nu,1);"; \
	echo "u(1) = 1;"; \
        )> $1_input.m

$1_sspar.r:
	echo Creating $1_sspar.r
	(\
	echo "%% Reduce steady-state parameter file for $1 ($1_sspar.r)" \
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo 'END;'; \
	)> $1_sspar.r

$1_rep.txt:
	echo Creating $1_rep.txt
	( \
	echo "%% Outline report file for system $1 ($1_rep.txt)"; \
	cat $MTTPATH/trans/m/rcs_header.txt; \
	echo "abg ps"; \
	echo "lbl txt"; \
	echo "cbg ps"; \
	echo "dae tex"; \
	)> $1_rep.txt


#Raw bond graph: fig file to mfile
$1_rbg.m: $1_abg.fig $1_lbl.txt
	rbg_fig2m $1
$1_cmp.m: $1_rbg.m
$1_fig.fig: $1_rbg.m

#Subsystem creation commands
$1_sub.sh: $1_cmp.m
	cmp2sub_m2sh $1

# Lbl to sympar conversion
$1_sympar.r: $1_lbl.txt
	lbl2sympar_txt2r $1

#Raw bond graph to acausal bond graph: mfile
$1_abg.m: $1_rbg.m $1_sub.sh

	echo Creating subsystem abg files for system $1 ...
	sh < $1_sub.sh
	echo Finished creating subsystem abg files for system $1
	echo
	rbg2abg_m $1	

#Causal bond graph: mfile to fig conversion
$1_cbg.fig: $1_cbg.m $1_rbg.m $1_fig.fig
	cbg_m2fig $1

#Acausal bond graph to causal bond graph: mfile
$1_cbg.m: $1_abg.m
	abg2cbg_m $1

#Elementary system equations + definitions
$1_ese.r: $1_cbg.m
	   cbg2ese_m2r $1
$1_def.r: $1_ese.r
	touch $1_def.r
$1_def.m: $1_def.r
	def_r2m $1; matlab_tidy $1_def.m;


#Differential-algebraic equations
$1_dae.r: $1_ese.r $1_cr.r $1_sympar.r
	ese2dae_r $1; tidy $1_dae.r
$1_dae.m: $1_def.r $1_dae.r  $1_sympar.r
	dae_r2m $1; matlab_tidy $1_dae.m; matlab_tidy $1_daeo.m
$1_dae.c: $1_def.r $1_dae.r  $1_sympar.r
	dae_r2c $1; c_tidy $1_dae.c
$1_dae.tex:	$1_dae.r $1_simp.r
	dae_r2tex $1; latex_tidy $1_dae.tex

#Constrained-state equations
$1_cse.r: $1_dae.r $1_def.r $1_sympar.r
	dae2cse_r $1; tidy $1_cse.r
$1_cse.m: $1_def.r $1_cse.r $1_sympar.r
	cse_r2m $1; matlab_tidy $1_cse.m
$1_cse.tex: $1_cse.r  $1_sympar.r
	cse_r2tex $1; latex_tidy $1_cse.tex

#Ordinary differential equations
$1_ode.r: $1_cse.r $1_def.r $1_sympar.r
	cse2ode_r $1; tidy $1_ode.r
$1_ode.m: $1_def.r $1_ode.r $1_sympar.r
	ode_r2m $1; matlab_tidy $1_ode.m; matlab_tidy $1_odeo.m
$1_ode.tex: $1_ode.r  $1_sympar.r $1_simp.r
	ode_r2tex $1; latex_tidy $1_ode.tex

#Observer functions for GPC
$1_obs.r: $1_ode.r $1_def.r $1_sympar.r
	ode2obs_r $1; tidy $1_obs.r
$1_obs.m: $1_def.r $1_obs.r $1_sympar.r
	obs_r2m $1; matlab_tidy $1_obs.m
$1_obs.tex: $1_obs.r  $1_sympar.r $1_simp.r
	obs_r2tex $1; latex_tidy $1_obs.tex


#Robot-form equations
$1_rfe.r: $1_cse.r $1_csm.r $1_def.r $1_sympar.r
	cse2rfe_r $1; tidy $1_rfe.r
$1_rfe.tex: $1_rfe.r  $1_sympar.r
	rfe_r2tex $1; latex_tidy $1_rfe.tex

#Steady-states
$1_ss.r: $1_def.r $1_sspar.r $1_sympar.r $1_cr.r $1_dae.r
	sspar2ss_r $1; tidy $1_ss.r
$1_ss.m: $1_def.r $1_sympar.r $1_ss.r 
	ss_r2m $1; matlab_tidy $1_ss.m
$1_ss.tex: $1_def.r $1_ss.r  $1_sympar.r $1_simp.r
	ss_r2tex $1; latex_tidy $1_ss.tex 


#Linearised system: descriptor matrices
$1_dm.r: $1_dae.r $1_def.r $1_cr.r  $1_ss.r $1_sympar.r
	dae2dm_r $1; tidy $1_dm.r
$1_dm.m: $1_def.r $1_dm.r $1_sympar.r
		dm_r2m $1; matlab_tidy $1_dm.m
$1_dm.tex: $1_dm.r $1_sympar.r $1_simp.r 
	dm_r2tex $1; latex_tidy $1_dm.tex


#Linearised system: constrained-state matrices
$1_csm.r: $1_cse.r $1_def.r $1_cr.r $1_ss.r $1_sympar.r
	cse2csm_r $1; tidy $1_csm.r
$1_csm.m: $1_def.r $1_csm.r
		csm_r2m $1;  matlab_tidy $1_csm.m
$1_csm.tex: $1_csm.r  $1_sympar.r $1_simp.r
	csm_r2tex $1; latex_tidy $1_csm.tex

#Linearised system: state matrices
$1_sm.r: $1_csm.r $1_def.r $1_cr.r $1_ss.r $1_sympar.r
	csm2sm_r $1; tidy $1_sm.r
$1_sm.m: $1_def.r $1_sm.r
		sm_r2m $1;  matlab_tidy $1_sm.m
$1_sm.tex: $1_sm.r  $1_sympar.r $1_simp.r
	sm_r2tex $1; latex_tidy $1_sm.tex

#Linearised system: transfer function
$1_tf.r: $1_dm.r $1_sympar.r 
	dm2tf_r $1; tidy $1_tf.r
$1_tf.m: $1_def.r $1_tf.r
	tf_r2m $1; matlab_tidy $1_tf.m
$1_tf.tex: $1_def.r $1_tf.r $1_sympar.r $1_simp.r
	tf_r2tex $1; latex_tidy $1_tf.tex


#Time responses
$1_ir.m: $1_sm.m $1_numpar.m $1_params.m $1_args.m $1_def.m
	sm2ir_m $1 '$ARGS'
$1_iro.m: $1_ir.m
	touch $1_iro.m
$1_sr.m: $1_sm.m $1_numpar.m $1_params.m $1_args.m $1_def.m
	sm2sr_m $1 '$ARGS'
$1_sro.m: $1_sr.m
	touch $1_sro.m
$1_odes.m: $1_ode.m $1_numpar.m $1_params.m $1_args.m $1_def.m $1_input.m
	ode2odes_m $1 '$ARGS'
$1_odeso.m: $1_odes.m
	touch $1_odeso.m
$1_daes.m: $1_dae.m $1_numpar.m $1_params.m $1_args.m $1_def.m $1_input.m
	dae2daes_m $1 '$ARGS'
$1_daeso.m: $1_daes.m
	touch $1_daeso.m

#Numerical steady states
$1_odess.m: $1_ode.m $1_numpar.m $1_params.m $1_args.m $1_def.m $1_input.m
	ode2odess_m $1 '$ARGS'

$1_odesso.m: $1_odess.m
	touch $1_odesso.m


#Frequency responses
$1_fr.m: $1_dm.m $1_numpar.m $1_params.m $1_args.m $1_def.m
	dm2fr_m $1 '$ARGS'
$1_lmfr.m: $1_fr.m
	touch $1_lmfr.m
$1_lpfr.m: $1_fr.m
	touch $1_lpfr.m
$1_nyfr.m: $1_fr.m
	touch $1_nyfr.m
$1_nifr.m: $1_fr.m
	touch $1_nifr.m

#Partially-known system indentification structure matrices
$1_pkim.r: $1_tf.r $1_sympar.r 
	tf2pkim_r $1; tidy $1_pki.r
$1_pkim.tex: $1_def.r $1_pkim.r $1_sympar.r
	pkim_r2tex $1; latex_tidy $1_pkim.tex

#Generic conversion of data files from m to dat format
$1_$2.dat: $1_$2.m
	m2dat $1_$2

#Generic conversion of data files from dat to (gplot) gdat format
$1_$2.gdat: $1_$2.dat
	dat2gdat $1_$2

#Generic conversion of Latex to latex document
$1_$2.doc: $1_$2.tex
	tex2doc $1 $2

#Generic conversion of LaTeX doc to dvi
$1_$2.dvi: $1_$2.doc
	echo Creating $1_$2.dvi
	latex $1_$2.doc > /dev/null

#Create PostScript version of fig files
ifeq ($REPTYPE,bg)
$1_$2.ps : $1_$2.fig
	echo Creating $1_$2.ps
	fig2dev -Lps $1_$2.fig >$1_$2.ps
endif

ifeq ($REPTYPE,data)
#Create PostScript version of dat file
$1_$2.ps: $1_$2.gdat
	gdat2ps $1_$2 '$ARGS'
endif

ifeq ($REPTYPE,tex)
#Create PostScript version of dvi file
$1_$2.ps: $1_$2.dvi
	echo Creating $1_$2.ps
	dvips -o $1_$2.ps $1_$2
endif

#Default view
ifeq ($REPTYPE,bg)
$1_$2.view : $1_$2.pview
endif

ifeq ($REPTYPE,data)
$1_$2.view : $1_$2.dview
endif

ifeq ($REPTYPE,tex)
$1_$2.view : $1_$2.tview
endif

#View a ps file
$1_$2.pview: $1_$2.ps
	echo Creating view of $1_$2
	$PSVIEW $1_$2.ps&

#View a gdat file
$1_$2.dview: $1_$2.gdat
	echo Creating view of $1_$2
	gdat2view $1_$2 '$ARGS'&
	
#View a tex file
$1_$2.tview: $1_$2.dvi
	echo Creating view of $1_$2
	$DVIVIEW $1_$2.dvi&
	

#Report generation
$1_rep.make: $1_rep.txt
	rep_txt2make $1
$1_rep.tex: $1_rep.make $(cat $1_rep.make 2>/dev/null)
	rep_txt2tex $1;
#$1_rep.make: $1_rep.tex
#	touch $1_rep.make
#$1_rep.rep: $1_rep.make
#	sh<$1_rep.make; cp $1_rep.tex $1_rep.doc

$1_rep.html: $1_rep.dvi
	echo Creating $1_rep.html 
	latex2html $1_rep.tex

# Version control system - uses RCS
RCS:
	echo Creating RCS
	mkdir RCS
$1_$2.vc: RCS 
	echo Version control on $1_$2.$VCext
	ci -I $1_$2.$VCext </dev/tty  ; co -l $1_$2.$VCext 

EOF
