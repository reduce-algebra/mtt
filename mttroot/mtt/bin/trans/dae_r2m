#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: dae_r2m
# Reduce DAE to simulab  DAE  
# P.J.Gawthrop 14 June 1991, 12 Jan 1994, April 1994, Jan 95.
# Copyright (c) P.J.Gawthrop 1991, 1994, 1995, 1996

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
## Revision 1.3  1996/08/16 13:10:53  peter
## Fixed bug Ny changed to Nx in redidual loop.
##
## Revision 1.2  1996/08/16 08:57:34  peter
## Reads $1_input.
##
## Revision 1.1  1996/08/15 16:46:06  peter
## Initial revision
##
###############################################################


# WARNING this is experimental!!
# It asumes that the output y is NOT dependent on derivatives of
#  z or u.


#Inform user
echo Creating $1_dae.m
echo Creating $1_daeo.m


# Remove the old log file
rm -f dae_r2m.log

# Use reduce to accomplish the transformation
reduce >dae_r2m.log << EOF

%Read the reduce definitions file
in "$1_def.r";

%Read the reduce  DAE   file
in "$1_dae.r";

%Set up the number of argument variables to zero in case the user has forgotten
MTTNVar := 0;

%Read the parameter file
in "$1_sympar.r";


ON NERO;        % Suppress zero elements

%Define the common part of the functions.

PROCEDURE common;
BEGIN
  IF MTTNvar>0 THEN
  BEGIN
    write "% Read in the parameters";
    write "[ ...;;";
    FOR i := 1:MTTNvar DO
    BEGIN
       IF i<MTTNvar THEN write MTTVar(i,1), ",..."
                    ELSE write MTTVar(i,1), "] = $1_numpar"
    END;
  END;
  
  write "% Read in the input";
  write "u = $1_input(t)";

  write "% Read in the arguments";
  write "$1_args";
  
  write "% Set up the State variables";
  FOR i := 1:MTTNx DO
  BEGIN
    write "MTTx", i, " = MTTx(", i, ");";
  END;

  write "% Set up the non-state variables";
  FOR i := 1:MTTNz DO
  BEGIN
    write "MTTz", i, " = MTTx(", MTTNx+ i, ");";
  END;

   write "% Set up the internal inputs";
  FOR i := 1:MTTNz DO
  BEGIN
    write "MTTui", i, " = MTTx(", MTTNx+MTTz+i, ");";
  END;
  
  write "% Set up the Input variables";
  IF MTTNu>0 THEN
  FOR i := 1:MTTNu DO
  BEGIN
    write "MTTu", i, " = u(", i, ");";
  END;
END;
  
% Firstly do the residual = f(dx,x,t) function.

%MTTGx and u are the derivatives of z wrt x and u respectively

% Find MTTGx;
matrix MTTGx(MTTNz,MTTNx);
FOR j := 1:MTTNx DO
  BEGIN
  xj := MTTX(j,1);
  FOR i := 1:MTTNz DO
    MTTGx(i,j) := df(MTTZ(i,1), xj, 1);
  END;

% Find MTTGu;
matrix MTTGu(MTTNz,MTTNu);
FOR j := 1:MTTNu DO
  BEGIN
  uj := MTTu(j,1);
  FOR i := 1:MTTNz DO
    MTTGu(i,j) := df(MTTZ(i,1), uj, 1);
  END;


OUT "$1_dae.m";
write "function residual = $1_dae(MTTdX0,MTTx,t);";
write "% residuals = $1_dae(dx,x,t);";
write "%DAE in DASSL $1;;";
write "%File $1_dae.m;;";
write "%Generated by MTT;;";


common();
  write "% Set up the non-state derivatives";
  FOR i := 1:MTTNz DO
  BEGIN
    write "MTTdz", i, " = MTTdx0(", MTTNx+ i, ");";
  END;
  

%Fortran switches - one line expressions
OFF echo;
ON fort$
cardno!* := 1$
fortwidth!* := 100$
OFF period$


MTTdx := MTTdx;
MTTGx := MTTGx;

OFF fort;

write "for i=1:", MTTNx, ";;";
write "  residual(i) = MTTdX(i)-MTTdX0(i);";
write "end;";

IF MTTNz>0 THEN
BEGIN
  write "dxz = MTTGx*MTTdx";
  write "for i=1:", MTTNz, ";;";
  write "  residual(i+", MTTNx, ") = dxz(i)-MTTdX0(i+", MTTNx,");";
  write "end;";
END;



SHUT "$1_dae.m";

OFF fort;

% Now do the y = g(x,t) function.
OUT "$1_daeo.m";
  
write "function MTTy = $1_daeo(MTTx,t);";
write "% dX = $1_daeo(MTTx,t);";
write "%DAE in Simulab form for system $1;;";
write "%File $1_daeo.m;;";
write "%Generated by MTT;;";

common();

%Fortran switches - one line expressions
OFF echo;
ON fort$
cardno!* := 1$
fortwidth!* := 100$
OFF period$

MTTy := MTTy;

SHUT "$1_daeo.m";








