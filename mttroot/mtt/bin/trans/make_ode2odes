#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
## Revision 1.11  1998/08/25 12:28:31  peterg
## Move initila switch to after initial input
##
## Revision 1.10  1998/08/25 12:22:45  peterg
## Put _switch after update and also at initilisation
##
## Revision 1.9  1998/08/15 13:46:59  peterg
## New versions of integration routines
##
## Revision 1.8  1998/08/11 13:28:03  peterg
## Lowercase mttLAST etc
##
## Revision 1.7  1998/07/30 11:29:54  peterg
## Added implicit integration stuff
##
## Revision 1.6  1998/07/30 10:44:37  peterg
## INcluded othe integration methods.
##
## Revision 1.5  1998/07/26 11:02:20  peterg
## Put mtt or MTT  in front of variable names to avoid clashes with
## globals
##
## Revision 1.4  1998/07/25 20:14:00  peterg
## update code added for flexibility and octave efficiency
##
###############################################################


# Bourne shell script: make_ode2odes

# Copyright (c) P.J.Gawthrop July 1998.

# Tell user
echo  Creating $1_ode2odes.m

Sys=$1

# Find system constants
Nx=`grep "MTTNx " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
Nu=`grep "MTTNu " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
Ny=`grep "MTTNy " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
 

cat << EOF > $1_ode2odes.m
# Program $1_ode2odes
EOF

# Do the globals
sympar2global_txt2m $1 >> $1_ode2odes.m

# The rest of the program
cat << EOF >> $1_ode2odes.m

$1_simpar;			# Read in simulation parameters
$1_numpar;			# Read in parameters
MTTilast = round(mttlast/mttdt); # Total number of steps

#Initialise
MTTt = 0.0;
[MTTx] = $1_state;	        # Read in initial state
[MTTu] = $1_input(MTTx,MTTt);	# Evaluate initial input
[MTTx] = $1_switch(MTTx);       # Switches
[MTTy] = $1_odeo(MTTx,MTTu,MTTt); # Evaluate initial output
mtt_write(MTTt,MTTx,MTTy,$Nx,$Ny); # And write them

[mttAA]  = zero_matrix($Nx);	# Zero the A matrix
[mttAAx] = zero_vector($Nx);	# Zero the AAx vector

  if mttmethod==1		# Euler
    MTTddt = mttdt/mttstepfactor; # The small sample interval
  endif;

#Integration loop
for MTTit = 1:MTTilast
  [MTTu] = $1_input(MTTx,MTTt);	# Input

  if mttmethod==1		# Euler
    for MTTjt = 1:mttstepfactor
      [MTTdx] = $1_ode(MTTx,MTTu,MTTt); # State derivative
      [MTTx] = mtt_euler(MTTx,MTTdx,MTTddt,$Nx); # Euler update
      MTTt = MTTt + MTTddt;
    endfor;
  endif;
  if mttmethod==2		# Implicit 
    [MTTdx] = $1_ode(MTTx,MTTu,MTTt); # State derivative
    [mttAA,mttAAx] = $1_smx(MTTx,MTTu,mttdt);	# (I-Adt) and (I-Adt)x
    [MTTx] = mtt_implicit(MTTx,MTTdx,mttAA,mttAAx,mttdt,$Nx); # Implicit update
    MTTt = MTTt + mttdt;
  endif;

  [MTTx] = $1_switch(MTTx);	# Switches

  [MTTy] = $1_odeo(MTTx,MTTu,MTTt);
  mtt_write(MTTt,MTTx,MTTy,$Nx,$Ny);
endfor;				# Integration loop

EOF




