#! /bin/sh


     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt_m2p
# Reduce octave 2 Pascal converter for MTT   
# P.J.Gawthrop July 1998
# Copyright (c) P.J.Gawthrop 1998

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
###############################################################



# Set up variables
args=`echo $1 | sed 's/_/ /' | sed 's/\./ /'`
Sys=`echo $args  | awk '{print $1}'`
sys=`echo $Sys  | awk '{print tolower($1)}'`
rep=`echo $args  | awk '{print $2}'`
Sys_rep="$Sys""_""$rep"
Filename="$Sys""_""$rep.p"
filename="$sys""_""$rep.p"

# Inform user
echo Creating $Filename

# Find system constants
Nx=`grep "MTTNx " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
Nu=`grep "MTTNu " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
Ny=`grep "MTTNy " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
 
#Regexps
  name="[a-zA-Z0-9]*"
  fun_name="$name\_$name"
  space="[ \t]*"
  spaces="[ \t][ \t]*"
  non_space="[^ ]*"

# Heading
(case $rep in
    state)
        echo "PROCEDURE $Sys_rep(VAR mttx : StateVector);"
        ;;
    input)
        echo "PROCEDURE $Sys_rep(VAR mttu : InputVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttt : REAL);"
	;;
    ode)
	echo "PROCEDURE $Sys_rep(VAR mttdx: StateVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL);"
	;;
    odeo)
	echo "PROCEDURE $Sys_rep(VAR mtty : OutputVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL);"
	;;
    ode2odes)
	echo "PROGRAM $Sys_rep;"
	echo "TYPE"
	echo "    StateVector  =ARRAY[1..$Nx] OF REAL;"
	echo "    InputVector  =ARRAY[1..$Nu] OF REAL;"
	echo "    OutputVector =ARRAY[1..$Ny] OF REAL;"
	echo "VAR"
        echo "    t,LAST,DT : REAL;"
	echo "    mttx,mttdx      : StateVector;"
	echo "    mttu            : InputVector;"
	echo "    mtty            : OutputVector;"
	echo "    i,j,k,it,iLast,STEPFACTOR,METHOD : INTEGER;"
        ;;
    *)	echo "PROCEDURE $Sys_rep;"
        ;;
esac) > $Filename

cat<<EOF >> $Filename

{*** System $Sys, rep $rep, language Pascal, file $Filename ***}
{*** Translated by MTT from $Sys_rep.m on `date` ***}

EOF



# Body	
grep -v '^[ ]*function' < $Sys_rep.m  | sed "s/^$space%/#/" |\
awk -F# '{printf("%s",$1) 
          if (NF>1) printf("{* %s *}", $2)
          printf("\n") 
         }' |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($fun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($fun_name\)/\2(\1)/" |\
sed "s/$space\($non_space\)$spaces=$spaces\($fun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\($non_space\)$spaces=$spaces\($fun_name\)/\2(\1)/"  |\
awk '
BEGIN{
  comment_regexp = "{"
  doing_header = 1
  doing_globals = 0
  Nt = 9
  inc ="$I"
}
{
  if ($1=="global") 
    doing_globals = 1
  else{ 
    if (doing_globals==1){
      if (match($1,";")==0){
        global[++i]=$1;
      }
      else{
        doing_globals = 0
      }
    }
    else 
    {
      if ((doing_header==1)&&(doing_globals==0)) {
        if (rep=="ode2odes"){
          printf("VAR ");
          for (k=1;k<i;k++) printf("%s,",global[k])
          printf("%s : REAL;\n", global[i])
          printf("VAR "); for (k=1;k<=Nx;k++) printf("mttx%i,", k)
          for (k=1;k<=Nu;k++) printf("mttu%i,", k)
          for (k=0;k<Nt;k++) printf("t%i,", k)
          printf("t%i : REAL;\n",Nt) 
          printf("{%s %s_simpar.p}\n",inc,sys) 
          printf("{%s %s_numpar.p}\n",inc,sys)
          printf("{%s %s_state.p}\n",inc,sys)
          printf("{%s %s_input.p}\n",inc,sys)
          printf("{%s %s_ode.p}\n",inc,sys)
          printf("{%s %s_odeo.p}\n",inc,sys)
          printf("{%s mtt_write.p}\n",inc,sys)
        }
        for (k=1;k<=j;k++) printf("%s\n", comment[k])
        printf("\n")
        printf("\nBEGIN\n")
        doing_header = 0;
      }
      if (match($1,comment_regexp)>0){
        if (doing_header==1)
          comment[++j] = $0
        else
          printf("%s\n", $0)
      }
      else {
        if ($1=="if") {
          print tolower($0)
          print "begin"
        }
        else{ 
          if ($1=="for"){
          sub(/:/," TO ",$0)
          sub(/=/,":=",$0)
          printf("%s DO\n", $0)
          print "begin"
          }
          else {
            sub(/=/,":=",$0)
            sub(/\^/,"**",$0)
            printf("%s\n",$0)
          }
        }
      }
    }
  }
}
END{
  if (rep=="def"){
    printf("EULER = 1,\n")
    printf("IMPLICITL = 2;\n")
    printf("IMPLICIT3 = 3;\n")
    }
    else
      print "END;"
}' sys=$sys rep=$rep Nx=$Nx Nu=$Nu |\
sed 's/(\([0-9]*\))/\[\1\]/' \
>> $Filename

# p2c doesn't like mixed case filenames!
echo Creating $filename
cp $Filename $filename


