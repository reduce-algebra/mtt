#! /bin/sh


     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt_m2p
# Reduce octave 2 Pascal converter for MTT   
# P.J.Gawthrop July 1998
# Copyright (c) P.J.Gawthrop 1998

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
## Revision 1.36  1999/11/29 06:49:26  peterg
## Upped number of mtt_tnn
##
## Revision 1.35  1999/11/15 22:47:17  peterg
## Generates method-specific code for the ode2odeso rep.
##
## Revision 1.34  1999/10/28 05:08:48  peterg
## Added elseif
##
## Revision 1.33  1999/09/17 04:25:01  peterg
## END --> END; in translation
##
## Revision 1.32  1999/08/29 06:54:42  peterg
## Added code (mtt_parameters, get args etc) to allow arguments to the
## a.out file
##
## Revision 1.31  1999/08/02 13:40:03  peterg
## Added zero-state and zero_input to include list
## Removed zero_matrix
##
## Revision 1.30  1999/04/20 06:16:46  peterg
## Removed calls to _switch.m
##
## Revision 1.29  1999/04/02 06:27:55  peterg
## Modified for new implicit method with swoitches
##
## Revision 1.28  1999/02/17 02:59:54  peterg
## Added -q switch to mtt
##
## Revision 1.27  1999/02/16 21:56:52  peterg
## Now gets standard include files directly from source,
##
## Revision 1.26  1999/02/16 21:43:54  peterg
## Revises smx generation.
##
## Revision 1.25  1999/02/16 04:38:09  peterg
## Now forces creation of _smx file if METHOD=IMPLICIT in simpar.txt
##
## Revision 1.24  1998/11/18 16:56:15  peterg
## Now handles comments after IFS
##
## Revision 1.23  1998/11/18 14:38:01  peterg
## Now convert ALL globals to VAR .. the last one isn't repeated now
##
## Revision 1.22  1998/11/17 17:39:45  peterg
## Put _smx include at end of list (?????)
##
## Revision 1.21  1998/11/17 17:26:11  peterg
## Put sign.p first
##
## Revision 1.20  1998/10/01 16:01:09  peterg
## Now does implicit integration with switches
##
## Revision 1.19  1998/09/29 15:37:18  peterg
## Declare mttINPUT
##
## Revision 1.18  1998/08/27 08:55:40  peterg
## Mods to integration methods
##
## Revision 1.17  1998/08/27 07:38:40  peterg
## About to change to new integration (Euler/Implicit only)
##
## Revision 1.16  1998/08/19 08:46:00  peterg
## Now translates ; % to #
##
## Revision 1.15  1998/08/15 13:46:01  peterg
## Included new sparse update routines
##
## Revision 1.14  1998/08/12 15:21:12  peterg
## Added type definition for the SVD procedures
##
## Revision 1.13  1998/08/11 09:32:07  peterg
## Added comments at procedure begin and end.
##
## Revision 1.12  1998/07/30 11:30:42  peterg
## Included zeros function
##
## Revision 1.11  1998/07/29 14:18:34  peterg
## Reorganised rep dependednt output
##
## Revision 1.10  1998/07/27 20:26:15  peterg
## Added new VARs mttWSTEPS, MTTWMIN,mttWMAX
##
## Revision 1.9  1998/07/27 17:20:42  peterg
## Allow , between ()
##
## Revision 1.8  1998/07/26 19:38:17  peterg
## Replaced t0..t9 by mtt_temp0..
##
## Revision 1.7  1998/07/25 20:06:23  peterg
## Does the mtt_update function
##
## Revision 1.6  1998/07/25 16:59:40  peterg
## Give other procedures local i,j vars.
##
## Revision 1.5  1998/07/25 15:06:17  peterg
## Added DDT VAR
##
## Revision 1.4  1998/07/25 15:05:54  peterg
## DD
##
## Revision 1.3  1998/07/25 14:03:30  peterg
## Added () to [] conversion when the variable is i j k or an integer or
## combination
##
## Revision 1.2  1998/07/25 12:39:57  peterg
## begin on same line as for and if
##
## Revision 1.1  1998/07/25 09:42:52  peterg
## Initial revision
##
###############################################################



# Set up variables
args=`echo $1 | sed 's/_/ /' | sed 's/\./ /'`
Sys=`echo $args  | awk '{print $1}'`
sys=`echo $Sys  | awk '{print tolower($1)}'`
rep=`echo $args  | awk '{print $2}'`
Sys_rep="$Sys""_""$rep"
Sys_smx="$Sys""_smx"
Sys_smxp="$Sys""_smx.p"
Filename="$Sys""_""$rep.p"
filename="$sys""_""$rep.p"

Method=$2; # The integration method
Stdin=$3;  # Using standard input

if [ -n "$Method" ]; then
  MethodBlurb=" with $Method integration method"
fi

if [ -n "$Stdin" ]; then
   StdinBlurb=" using standard input"
fi

# Inform user
  echo Creating $Filename $MethodBlurb $StdinBlurb 

# Find system constants
Nx=`mtt_getsize $Sys x` # States
Nu=`mtt_getsize $Sys u` # Inputs 
Ny=`mtt_getsize $Sys y` # Inputs 
Npar=`wc -l $Sys\_sympar.txt | awk '{print $1}'`

#if [ "$rep" = "simpar" ]; then
#    mtt -q $Sys smx p
#fi

# Heading
(case $rep in
    state)
        echo "PROCEDURE $Sys_rep(VAR mttx : StateVector);"
        ;;
    input)
        echo "PROCEDURE $Sys_rep(VAR mttu : InputVector;"
	echo "                       mttt : REAL;"
	echo "                       mttx : StateVector;"
	echo "                       mtty : OutputVector);"
	;;
    ode)
	echo "PROCEDURE $Sys_rep(VAR mttdx: StateVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL;"
	echo "                       mttpar : ParameterVector);"
	;;
    odeo)
	echo "PROCEDURE $Sys_rep(VAR mtty : OutputVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL;"
	echo "                       mttpar : ParameterVector);"
	;;
    cse)
	echo "PROCEDURE $Sys_rep(VAR mttdx: StateVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL;"
	echo "                       mttpar : ParameterVector);"
	;;
    cseo)
	echo "PROCEDURE $Sys_rep(VAR mtty : OutputVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL;"
	echo "                       mttpar : ParameterVector);"

	;;
    smx)
	echo "PROCEDURE $Sys_rep(VAR mtta       : StateMatrix;"
	echo "                   VAR mttax,mttx : StateVector;"
	echo "                   VAR mttu       : InputVector;"
	echo "                       mttdt      : REAL);"
	;;
    ode2odes)
	echo "PROGRAM $Sys_rep;"
	echo "CONST"
	echo "    MTT_MaxParameters = 100;"
	echo "TYPE"
	echo "    StateVector  = ARRAY[1..$Nx] OF REAL;"
	echo "    InputVector  = ARRAY[1..$Nu] OF REAL;"
	echo "    OutputVector = ARRAY[1..$Ny] OF REAL;"
	echo "    ParameterVector = ARRAY[1..$Npar] OF REAL;"
	echo "    StateMatrix  = ARRAY[1..$Nx,1..$Nx] OF REAL;"
	echo "    glnparray    = StateVector;"
	echo "    glmparray    = StateVector;"
	echo "    glnarray     = StateVector;"
	echo "    glnpbynp     = StateMatrix;"
	echo "    glmpbynp     = StateMatrix;"
	## echo "    IntegrationMethod = 1..4;"
	echo ""
	echo "VAR"
        echo "    MTTt,mttLAST,mttDT,mttDDT   : REAL;"
        echo "    MTTWMIN,mttWMAX             : REAL;"
	echo "    mttx,mttdx,mttxx,mttAAx     : StateVector;"
	echo "    mttu                        : InputVector;"
	echo "    mtty                        : OutputVector;"
	echo "    mttpar                      : ParameterVector;"
	echo "    mttAA, mttE                 : StateMatrix;"
	echo "    MTTi,MTTj,MTTit,MTTjt,MTTiLast: INTEGER;"
	echo "    mttSTEPFACTOR,mttWSTEPS,mttSTEPS,mttINPUT : INTEGER;"
	## echo "    mttMETHOD : IntegrationMethod;"
	echo "    MTTopen  : StateVector;"
	echo "    mtt_parameters  : ARRAY[1..MTT_MaxParameters] OF REAL;"
	echo "    mtt_n_parameters  : INTEGER;"
	echo ""
        ;;
    switchopen)
	echo "PROCEDURE $Sys_rep(VAR open : StateVector; mttx : StateVector);"
	echo "VAR"
	echo "    MTTi,MTTj :  INTEGER;"
	;;
    *)	echo "PROCEDURE $Sys_rep;"
	echo "VAR"
	echo "    MTTi,MTTj :  INTEGER;"
        ;;
esac) > $Filename

cat<<EOF >> $Filename

{*** System $Sys, rep $rep, language Pascal, file $Filename ***}
{*** Translated by MTT from $Sys_rep.m on `date` ***}

EOF

# Regexps
  name="[a-zA-Z0-9_]*"
  fun_name="$Sys\_$name"
  mttfun_name=$name
  tab='	'
  space="[ $tab]*"
  spaces="[ $tab][ $tab]*"
  non_space="[^ ]*"

# Body	
grep -v '^[ ]*function' < $Sys_rep.m  | sed "s/^$space%/#/" | sed "s/\([;)]$space\)%/\1#/" |\
awk -F# '{printf("%s",$1) 
          if (NF>1) printf("{* %s *}", $2)
          printf("\n") 
         }' |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($fun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($mttfun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\(zeros\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($fun_name\)/\2(\1)/" |\
sed "s/$space\($non_space\)$spaces=$spaces\($fun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\($non_space\)$spaces=$spaces\($fun_name\)/\2(\1)/"  |\
awk '
function printvar(Name,N) {
  if (N<1) return;
  width = 10;
  kk = 0; 
  printf("VAR\n");
  for (k=1;k<=N;k++) {
    printf("mtt%s%i", Name, k);
    if (k==N)
      printf(" : REAL;\n")
    else
      printf(", "); 
    kk++;
    if (kk==width){printf("\n"); kk=0}
  }
}
BEGIN{
  comment_regexp = "{"
  doing_header = 0
  doing_globals = 0
  Nt = 99
  inc ="$I"
}
{
  if ($1=="global") 
    doing_globals = 1
  else{ 
    if (doing_globals==1){
      global[++i]=$1; 
      if (match($0,";")==0){
      }
      else{
        doing_globals = 0
        doing_header = 1
      }
    }
    else 
    {
      if (doing_header==1){
        if (rep=="ode2odes"){
          printf("VAR \n");
          for (k=1;k<i;k++) printf("  %s,\n",global[k])
          printf("%s : REAL;\n", global[i])
          # printvar("x",Nx);
          # printvar("u",Nu);
          # printvar("y",Ny);
          printvar("_t",Nt);

          printf("\n{%s $MTTPATH/trans/p/mtt_write.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/sign.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/mtt_euler.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/mtt_solve.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/mtt_implicit.p}\n",inc)
          # printf("{%s $MTTPATH/trans/p/zero_matrix.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/zero_input.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/zero_state.p}\n",inc)
          printf("{%s $MTTPATH/trans/p/mtt_getargs.p}\n",inc)
          printf("{%s %s_simpar.p}\n",inc,Sys) 
          printf("{%s %s_numpar.p}\n",inc,Sys)
          printf("{%s %s_state.p}\n",inc,Sys)
          printf("{%s %s_input.p}\n",inc,Sys)
          if (Method=="euler") {
            printf("{%s %s_ode.p}\n",inc,Sys)
            printf("{%s %s_odeo.p}\n",inc,Sys)
          }
          if (Method=="implicit") {
            printf("{%s %s_cse.p}\n",inc,Sys)
            printf("{%s %s_cseo.p}\n",inc,Sys)
            printf("\n{%s %s_smx.p}\n",inc,Sys);
          }
          printf("{%s %s_switchopen.p}\n\n",inc,Sys)

          for (k=1;k<=j;k++) printf("%s\n", comment[k])
          printf("\n")
          printf("\nBEGIN{%s}\n", Sys_rep)
        }
        else{
          for (k=1;k<=j;k++) printf("%s\n", comment[k])
          printf("\n")
          printf("\nBEGIN{%s}\n", Sys_rep)
       }
        doing_header = 0;
      }
      if (match($1,comment_regexp)>0){
        if (doing_header==1)
          comment[++j] = $0
        else
          printf("%s\n", $0)
      }
      else {
        if ($1=="if") {
          sub(/==/, "=", $0)
            gsub(/&&/," AND ",$0)
            gsub(/\|\|/," OR ",$0)
          printf("%s THEN BEGIN\n", $0)
        }
        else { 
          if ((match($1,"mtt_write")>0)&&(length(Stdin)>0)) {
           sub(/mtt_write/, "if NOT eof THEN mtt_write");
          }
          if ($1=="for"){
            if (($2=="MTTit")&&(length(Stdin)>0)){
	      printf("WHILE NOT eof DO BEGIN {Integration loop}")
            }
            else {
              sub(/:/," TO ",$0)
              sub(/=/,":=",$0)
              printf("%s DO BEGIN\n", $0)
            } 
          }
          else{
            sub(/=/,":=",$0)
            sub(/endif/,"END;{IF}",$0)
            sub(/endfor/,"END;{FOR}",$0)
            sub(/elseif/,"END ELSEIF BEGIN",$0)
            sub(/else/,"END ELSE BEGIN",$0)
            gsub(/\^/,"**",$0)
            gsub(/&&/," AND ",$0)
            gsub(/\|\|/," OR ",$0)
            printf("%s\n",$0)
          }
        }
      }
    }
  }
}
END{
  if (rep=="def"){
    printf("EULER = 1,\n")
    printf("IMPLICITL = 2;\n")
    printf("IMPLICIT = 3;\n")
    }
    else
      if (rep=="ode2odes")
                printf("END{%s}.\n", Sys_rep)
      else
        printf("END{%s};\n", Sys_rep)
}' Sys=$Sys sys=$sys Sys_rep=$Sys_rep rep=$rep \
   Nx=$Nx Nu=$Nu Ny=$Ny Method=$Method Stdin=$Stdin |\
sed 's/(\([ijk0-9,]*\))/\[\1\]/g'    |\
sed 's/(\(MTT[ijk0-9],[0-9]*\))/\[\1\]/g' |\
sed 's/(\([0-9]*,MTT[ijk0-9]\))/\[\1\]/g' |\
sed 's/(\(MTT[ijk0-9],MTT[ijk0-9]\))/\[\1\]/g' |\
sed 's/(\(MTT[ijk0-9,]*\))/\[\1\]/g'  |\
sed 's/switcha(mttAA,/switcha(/g'   |\
sed 's/switch(MTTx,/switch(/g'  \
>> $Filename

# p2c doesn't like mixed case filenames!
#if [ "$Filename" != "$filename" ]; then
#  echo Creating $filename
#  cp -f $Filename $filename
#fi

if [ "$rep" = "ode2odes" ]; then
    # Explicitly include files
    mtt_pinclude $Filename>junk.p
    mv junk.p $Filename
fi



