#! /bin/sh


     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt_m2p
# Reduce octave 2 Pascal converter for MTT   
# P.J.Gawthrop July 1998
# Copyright (c) P.J.Gawthrop 1998

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
## Revision 1.17  1998/08/27 07:38:40  peterg
## About to change to new integration (Euler/Implicit only)
##
## Revision 1.16  1998/08/19 08:46:00  peterg
## Now translates ; % to #
##
## Revision 1.15  1998/08/15 13:46:01  peterg
## Included new sparse update routines
##
## Revision 1.14  1998/08/12 15:21:12  peterg
## Added type definition for the SVD procedures
##
## Revision 1.13  1998/08/11 09:32:07  peterg
## Added comments at procedure begin and end.
##
## Revision 1.12  1998/07/30 11:30:42  peterg
## Included zeros function
##
## Revision 1.11  1998/07/29 14:18:34  peterg
## Reorganised rep dependednt output
##
## Revision 1.10  1998/07/27 20:26:15  peterg
## Added new VARs mttWSTEPS, MTTWMIN,mttWMAX
##
## Revision 1.9  1998/07/27 17:20:42  peterg
## Allow , between ()
##
## Revision 1.8  1998/07/26 19:38:17  peterg
## Replaced t0..t9 by mtt_temp0..
##
## Revision 1.7  1998/07/25 20:06:23  peterg
## Does the mtt_update function
##
## Revision 1.6  1998/07/25 16:59:40  peterg
## Give other procedures local i,j vars.
##
## Revision 1.5  1998/07/25 15:06:17  peterg
## Added DDT VAR
##
## Revision 1.4  1998/07/25 15:05:54  peterg
## DD
##
## Revision 1.3  1998/07/25 14:03:30  peterg
## Added () to [] conversion when the variable is i j k or an integer or
## combination
##
## Revision 1.2  1998/07/25 12:39:57  peterg
## begin on same line as for and if
##
## Revision 1.1  1998/07/25 09:42:52  peterg
## Initial revision
##
###############################################################



# Set up variables
args=`echo $1 | sed 's/_/ /' | sed 's/\./ /'`
Sys=`echo $args  | awk '{print $1}'`
sys=`echo $Sys  | awk '{print tolower($1)}'`
rep=`echo $args  | awk '{print $2}'`
Sys_rep="$Sys""_""$rep"
Filename="$Sys""_""$rep.p"
filename="$sys""_""$rep.p"

# Inform user
echo Creating $Filename

# Find system constants
Nx=`grep "MTTNx " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
Nu=`grep "MTTNu " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
Ny=`grep "MTTNy " <$Sys\_def.r | awk '{print $3}' | sed 's/;//'`
 
# Heading
(case $rep in
    state)
        echo "PROCEDURE $Sys_rep(VAR mttx : StateVector);"
        ;;
    input)
        echo "PROCEDURE $Sys_rep(VAR mttu : InputVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttt : REAL);"
	;;
    ode)
	echo "PROCEDURE $Sys_rep(VAR mttdx: StateVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL);"
	;;
    odeo)
	echo "PROCEDURE $Sys_rep(VAR mtty : OutputVector;"
	echo "                       mttx : StateVector;"
	echo "                       mttu : InputVector;"
	echo "                       mttt : REAL);"
	;;
    smx)
	echo "PROCEDURE $Sys_rep(VAR mtta       : StateMatrix;"
	echo "                   VAR mttax,mttx : StateVector;"
	echo "                   VAR mttu       : InputVector;"
	echo "                       mttdt      : REAL);"
	;;
    ode2odes)
	echo "PROGRAM $Sys_rep;"
	echo "TYPE"
	echo "    StateVector  = ARRAY[1..$Nx] OF REAL;"
	echo "    InputVector  = ARRAY[1..$Nu] OF REAL;"
	echo "    OutputVector = ARRAY[1..$Ny] OF REAL;"
	echo "    StateMatrix  = ARRAY[1..$Nx,1..$Nx] OF REAL;"
	echo "    glnparray    = StateVector;"
	echo "    glmparray    = StateVector;"
	echo "    glnarray     = StateVector;"
	echo "    glnpbynp     = StateMatrix;"
	echo "    glmpbynp     = StateMatrix;"
	echo "    IntegrationMethod = 1..4;"
	echo ""
	echo "VAR"
        echo "    MTTt,mttLAST,mttDT,mttDDT   : REAL;"
        echo "    MTTWMIN,mttWMAX             : REAL;"
	echo "    mttx,mttdx,mttxx,mttAAx     : StateVector;"
	echo "    mttu                        : InputVector;"
	echo "    mtty                        : OutputVector;"
	echo "    mttAA                       : StateMatrix;"
	echo "    MTTi,MTTj,MTTit,MTTjt,MTTiLast,mttSTEPFACTOR,mttWSTEPS,mttSTEPS : INTEGER;"
	echo "    mttMETHOD : IntegrationMethod;"
	echo ""
        ;;
    switch)
	echo "PROCEDURE $Sys_rep(VAR mttxs : StateVector;"
	echo "                       mttx  : StateVector);"
	echo "VAR"
	echo "    MTTi,MTTj :  INTEGER;"
	;;
    *)	echo "PROCEDURE $Sys_rep;"
	echo "VAR"
	echo "    MTTi,MTTj :  INTEGER;"
        ;;
esac) > $Filename

cat<<EOF >> $Filename

{*** System $Sys, rep $rep, language Pascal, file $Filename ***}
{*** Translated by MTT from $Sys_rep.m on `date` ***}

EOF

#Regexps
  name="[a-zA-Z0-9_]*"
  fun_name="$Sys\_$name"
  mttfun_name=$name
  tab='	'
  space="[ $tab]*"
  spaces="[ $tab][ $tab]*"
  non_space="[^ ]*"

# Body	
grep -v '^[ ]*function' < $Sys_rep.m  | sed "s/^$space%/#/" | sed "s/\(;$space\)%/\1#/" |\
awk -F# '{printf("%s",$1) 
          if (NF>1) printf("{* %s *}", $2)
          printf("\n") 
         }' |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($fun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($mttfun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\(zeros\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\[\($non_space\)\]$spaces=$spaces\($fun_name\)/\2(\1)/" |\
sed "s/$space\($non_space\)$spaces=$spaces\($fun_name\)(\([a-zA-Z0-9,]*\))/\2(\1,\3)/" |\
sed "s/$space\($non_space\)$spaces=$spaces\($fun_name\)/\2(\1)/"  |\
awk '
function printvar(Name,N) {
  if (N<1) return;
  width = 10;
  kk = 0; 
  printf("VAR\n");
  for (k=1;k<=N;k++) {
    printf("mtt%s%i", Name, k);
    if (k==N)
      printf(" : REAL;\n")
    else
      printf(", "); 
    kk++;
    if (kk==width){printf("\n"); kk=0}
  }
}
BEGIN{
  comment_regexp = "{"
  doing_header = 0
  doing_globals = 0
  Nt = 9
  inc ="$I"
}
{
  if ($1=="global") 
    doing_globals = 1
  else{ 
    if (doing_globals==1){
      if (match($1,";")==0){
        global[++i]=$1; 
      }
      else{
        doing_globals = 0
        doing_header = 1
      }
    }
    else 
    {
      if (doing_header==1){
        if (rep=="ode2odes"){
          printf("VAR \n");
          for (k=1;k<i;k++) printf("  %s,\n",global[k])
          printf("%s : REAL;\n", global[i])
          printvar("x",Nx);
          printvar("u",Nu);
          printvar("y",Ny);
          printvar("_t",Nt);

          printf("\n{%s %s_smx.p}\n",inc,sys)
          printf("\n{%s sign.p}\n",inc,sys)
          printf("{%s mtt_euler.p}\n",inc)
          printf("{%s mtt_implicit.p}\n",inc)
          printf("{%s mtt_write.p}\n",inc)
          printf("{%s zero_matrix.p}\n",inc)
          printf("{%s zero_vector.p}\n",inc)
          printf("{%s %s_simpar.p}\n",inc,sys) 
          printf("{%s %s_numpar.p}\n",inc,sys)
          printf("{%s %s_state.p}\n",inc,sys)
          printf("{%s %s_input.p}\n",inc,sys)
          printf("{%s %s_ode.p}\n",inc,sys)
          printf("{%s %s_odeo.p}\n",inc,sys)
          printf("{%s %s_switch.p}\n\n",inc,sys)

          for (k=1;k<=j;k++) printf("%s\n", comment[k])
          printf("\n")
          printf("\nBEGIN{%s}\n", Sys_rep)
        }
        else{
          for (k=1;k<=j;k++) printf("%s\n", comment[k])
          printf("\n")
          printf("\nBEGIN{%s}\n", Sys_rep)
       }
        doing_header = 0;
      }
      if (match($1,comment_regexp)>0){
        if (doing_header==1)
          comment[++j] = $0
        else
          printf("%s\n", $0)
      }
      else {
        if ($1=="if") {
          sub(/==/, "=", $0)
            gsub(/&&/," AND ",$0)
            gsub(/\|\|/," OR ",$0)
          printf("%s THEN BEGIN\n", $0)
        }
        else{ 
          if ($1=="for"){
          sub(/:/," TO ",$0)
          sub(/=/,":=",$0)
          printf("%s DO BEGIN\n", $0) 
          }
          else{
            sub(/=/,":=",$0)
            sub(/endif/,"END{IF}",$0)
            sub(/endfor/,"END{FOR}",$0)
            gsub(/\^/,"**",$0)
            gsub(/&&/," AND ",$0)
            gsub(/\|\|/," OR ",$0)
            printf("%s\n",$0)
          }
        }
      }
    }
  }
}
END{
  if (rep=="def"){
    printf("EULER = 1,\n")
    printf("IMPLICITL = 2;\n")
    printf("IMPLICIT = 3;\n")
    }
    else
      if (rep=="ode2odes")
                printf("END{%s}.\n", Sys_rep)
      else
        printf("END{%s};\n", Sys_rep)
}' Sys=$Sys sys=$sys Sys_rep=$Sys_rep rep=$rep Nx=$Nx Nu=$Nu Ny=$Ny |\
sed 's/(\([ijk0-9,]*\))/\[\1\]/g'  |\
sed 's/(\(MTT[ijk0-9,]*\))/\[\1\]/g' \
>> $Filename

# p2c doesn't like mixed case filenames!
if [ "$Filename" != "$filename" ]; then
  echo Creating $filename
  cp -f $Filename $filename
fi


