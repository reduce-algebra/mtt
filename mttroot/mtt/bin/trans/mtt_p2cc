#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: mtt_p2oct

# Pascal to .oct (octave loadable binary).
# P.J.Gawthrop Feb 2000
# Copyright (C) 2000 by Peter J. Gawthrop

    #$Id$	

# Find system constants
Nx=`mtt_getsize $1 x` # States
Nu=`mtt_getsize $1 u` # Inputs 
Ny=`mtt_getsize $1 y` # Inputs 

# Create numpar code
#mtt_p2C $1 numpar

# Create input code
#mtt_p2C $1 input

# Create the representation code
mtt_p2C $1 $2

# Inform user
echo Creating $1_$2.cc

# Create the c++ code
# Heading
date=`date`

cat > $1_$2.cc <<EOF
#include <octave/oct.h>

DEFUN_DLD ($1_$2, args, ,
	   "$1_$2 was generated by MTT on $date")
{
  ColumnVector mttx = args(0).vector_value ();
  ColumnVector mttu = args(1).vector_value ();
  double mttt = args(2).double_value ();
  ColumnVector mttpar = args(3).vector_value ();

EOF

case "$2" in
    ode)
	echo "  ColumnVector mttdx ($Nx);" >> $1_$2.cc
	;;
    odeo)
	echo "  ColumnVector mtty ($Ny);" >> $1_$2.cc
	;;
    cse)
	echo "  ColumnVector mttdx ($Nx);" >> $1_$2.cc
	;;
    cseo)
	echo "  ColumnVector mtty ($Ny);" >> $1_$2.cc
	;;
    smx | smxa | smxax)
        Nxx=`echo "$Nx*$Nx" | bc`
	echo "  ColumnVector mtta ($Nxx);" >> $1_$2.cc
	echo "  ColumnVector mttax ($Nx);" >> $1_$2.cc
	;;
    *)
	
esac

#Extract Type info
echo '/* Types */'                >> $1_$2.cc
grep typedef $1_$2.C              >> $1_$2.cc

#Extract any additional mtt_tmp variables
#awk 'BEGIN{
#  writing = 1;
#}
#{
#  if (match($1,"mtt")==1) writing=0;  
#  if ( (writing)&&(match($0,"mtt_t[0-9]")>0) ) print $0;
#}' < $1_$2.C >> $1_$2.cc

#Extract the numpar code
#echo '/* Numerical parameters */' >> $1_$2.cc
#awk '{
#  if ($1=="}") writing=0;
#  if (writing) print $0;
#  if ($1=="{") writing=1;
#}' <$1_numpar.C >> $1_$2.cc

#Extract the input code converting [] to ()
#echo "/* Input information */" >> $1_$2.cc
#awk '{
#  if ($1=="}") writing=0;
#  if (match($1,"mtt")==1) writing=1;
#  if (writing) print $0;
#}' <$1_input.C |\
#sed 's/\[\([0-9]*\)\]/(\1)/g' >> $1_$2.cc

#Extract the rep code and  converting [] to () and deleting mtt variables etc
echo "/* Representation $2 information */" >> $1_$2.cc
awk '{
  if ($1=="}") writing=0;
  if ( (writing)&&(match($2,"mtt")==0) ) print $0;
  if (match($1,"{")==1) writing=1;
}' <$1_$2.C |\
sed 's/\[\([0-9]*\)\]/(\1)/g' >> $1_$2.cc

# Tail
cat >> $1_$2.cc <<EOF

EOF

case "$2" in
    ode)
        echo "return octave_value (mttdx);" >> $1_$2.cc;
	;;
    odeo)
        echo "return octave_value (mtty); " >> $1_$2.cc;
	;;
    cse)
        echo "return octave_value (mttdx);" >> $1_$2.cc;
	;;
    cseo)
        echo "return octave_value (mtty); " >> $1_$2.cc;
	;;
    smxa)
        echo "return octave_value (mtta); " >> $1_$2.cc;
	;;
    smxax)
        echo "return octave_value (mttax); " >> $1_$2.cc;
	;;
    *)
	
esac

# Terminating }
echo "}" >> $1_$2.cc;
# Convert to octave loadable code
echo Creating $1_$2.oct
mkoctfile $1_$2.cc

