#! /bin/sh

     ###################################### 
     ##### Model Transformation Tools #####
     ######################################

# Bourne shell script: ode_r2m
# Reduce ODE to matlab  ODE  
# P.J.Gawthrop 14 June 1991, 12 Jan 1994, April 1994, Jan 95.
# Copyright (c) P.J.Gawthrop 1991, 1994, 1995, 1996

###############################################################
## Version control history
###############################################################
## $Id$
## $Log$
## Revision 1.12  1998/05/21 12:55:48  peterg
## Put in algebraic equation stuff
##
## Revision 1.11  1998/05/21 08:05:23  peterg
## Back under RCS
##
## Revision 1.10  1998/04/14 07:25:02  peterg
## _input now has arguments (x,t)
##
## Revision 1.9  1998/03/30 14:18:07  peterg
## Removed NERO command
##
## Revision 1.8  1998/02/25 18:03:49  peterg
## Removed the argument reading bits.
##
## Revision 1.7  1997/08/29 07:58:17  peterg
## Changed MTT to mtt in the .m files.
##
# Revision 1.6  1997/01/05  19:34:35  peterg
# Don't write globals which are already assigned to a number.
#
## Revision 1.5  1996/09/13 19:41:39  peter
## *** empty log message ***
##
## Revision 1.4  1996/09/12 18:33:32  peter
## Put back under rcs
##
## Revision 1.3  1996/08/30 11:04:28  peter
## Changed line length to 500.
##
## Revision 1.2  1996/08/24 14:09:41  peter
## Global parameter passing.
##
## Revision 1.1  1996/08/18 12:03:49  peter
## Initial revision
##
###############################################################

#Inform user
echo Creating $1_ode.m
echo Creating $1_odea.m
echo Creating $1_odeo.m


# Remove the old log file
rm -f ode_r2m.log

#Remove the temporary files
rm -f $1_ode.mc
rm -f $1_ode.m1
rm -f $1_ode.m2
rm -f $1_ode.m3
rm -f $1_ode.m4
rm -f $1_odea.m1;
rm -f $1_odeo.m1;

# Use reduce to accomplish the transformation
reduce >ode_r2m.log << EOF

%Read the reduce definitions file
in "$1_def.r";

%Read the reduce  ODE   file
in "$1_ode.r";

% Matrix output function
in"$MTTPATH/trans/matlab_matrix.r";


%Set up the number of argument variables to zero in case the user has forgotten
MTTNVar := 0;

%Read the parameter file
in "$1_sympar.r";

%ON NERO;        % Suppress zero elements

%Define the common part of the functions.

PROCEDURE common;
BEGIN
  write "% Read in the input";
  write "u = $1_input(x,t)";

  write "% Read in the definitions";
  write "[nx,ny,nu,nz,nyz] = $1_def";

%  write "% Read in the arguments";
%  write "$1_args";
  
  write "% Set up the State variables";
  FOR i := 1:MTTNx DO
  BEGIN
    write "mttx", i, " = x(", i, ");";
  END;
  
  write "% Set up the Input variables";
  IF MTTNu>0 THEN
  FOR i := 1:MTTNu DO
  BEGIN
    write "mttu", i, " = u(", i, ");";
  END;

END;

% The common part
OUT "$1_ode.mc";
common();
SHUT "$1_ode.mc";

% Set up internal inputs (if any)
OUT "$1_ode.m3";
  write "% Set up the Internal Input variables";
  IF MTTNyz>0 THEN
  FOR i := 1:MTTNyz DO
  BEGIN
    write "mttui", i, " = mttui(", i, ");";
  END;
SHUT "$1_ode.m3";

OUT "$1_ode.m4";
  write "% Set up the Internal Input variables (saved in the state vector)";
  IF MTTNyz>0 THEN
  FOR i := 1:MTTNyz DO
  BEGIN
    write "mttui(", i, ") = x(", i+MTTNx, ");";
  END;
SHUT "$1_ode.m4";

% The body of the ode function
  GENTRANOUT "$1_ode.m1";
  mtt_matrix := MTTdX$
  mtt_matrix_n := MTTNx$
  mtt_matrix_m := 1$
  mtt_matrix_name := MTTdX$
  matlab_matrix(); 
  GENTRAN MTTdx := mtt_matrix;
  GENTRANSHUT "$1_ode.m1";
  
% The algebraic equations (if any)
  GENTRANOUT "$1_odea.m1";
  mtt_matrix := MTTYz$
  mtt_matrix_n := MTTNYz$
  mtt_matrix_m := 1$
  mtt_matrix_name := MTTYz$
  matlab_matrix(); 
  GENTRAN MTTYz := mtt_matrix;
  GENTRANSHUT "$1_odea.m1";

 
%Fortran switches - one line expressions
OFF echo;
ON fort$
cardno!* := 1$
fortwidth!* := 10000$
OFF period$

MTTdx := MTTdx;


SHUT "$1_ode.m";

OUT "$1_odea.m";
write "function zero = $1_odea(x,t);";
write "% zero = $1_odea(x,t);";
write "%Algebraic equations in octave form for system $1;;";
write "%File $1_odea.m;;";
write "%Generated by MTT;;";

%Write algebraic equations if any ...
zero := MTTYz;
SHUT "$1_odea.m";

% Now do the y = g(x,t) function.
% The body of the odeo function
  GENTRANOUT "$1_odeo.m1";
  mtt_matrix := MTTy$
  mtt_matrix_n := MTTNy$
  mtt_matrix_m := 1$
  mtt_matrix_name := MTTy$
  matlab_matrix(); 
  GENTRAN MTTy := mtt_matrix;
  GENTRANSHUT "$1_odeo.m1";


EOF

# Create the ode.m function
cat <<EOF > $1_ode.m
function mttdx = $1_ode(x,t);
% mttdx = $1_ode(x,t);
%ODE in Octave form for system $1;
%File $1_ode.m;
%Generated by MTT on `date`;
EOF

# Create the globals
sympar2global_txt2m $1 >> $1_ode.m

#Common bit
cat $1_ode.mc >> $1_ode.m

#Extract internal input from state vector
cat $1_ode.m4 >> $1_ode.m

cat <<EOF >> $1_ode.m
% Solve the algebraic equations (if any)
if nyz>0
  global xx tt;
  xx = x; tt=t;
  mttui = fsolve('$1_odea',mttui);
else
 mttui = [];
end
EOF

cat $1_ode.m3 >> $1_ode.m

cat <<EOF >> $1_ode.m

% The differential equations
EOF
cat $1_ode.m1 >> $1_ode.m

cat <<EOF >> $1_ode.m

% Append the internal inputs to the state derivative
mttdx = [mttdx; mttui];
EOF


# Create the odea.m function
cat <<EOF > $1_odea.m
function mttyz = $1_odea(mttui);
% mttyz = $1_odea(mttui);
%Algebraic equations in Octave form for system $1;
%File $1_odea.m;
%Generated by MTT on `date`;
EOF

# Create the globals
sympar2global_txt2m $1 >> $1_odea.m

cat <<EOF >> $1_odea.m

global xx tt;
x = xx; t=tt;
EOF

#Common bit
cat $1_ode.mc >> $1_odea.m

# Internal inputs
cat $1_ode.m3 >> $1_odea.m

cat <<EOF >> $1_odea.m

% The algebraic equations
EOF
cat $1_odea.m1 >> $1_odea.m

# Create the odeo.m function
cat <<EOF > $1_odeo.m
function mtty = $1_odeo(x,t);
% mtty = $1_odeo(x,t);
%Algebraic equations in Octave form for system $1;
%File $1_odeo.m;
%Generated by MTT on `date`;
EOF

# Create the globals
sympar2global_txt2m $1 >> $1_odeo.m


#Common bit
cat $1_ode.mc >> $1_odeo.m

#Extract internal input from state vector
cat $1_ode.m4 >> $1_odeo.m

# Internal inputs
cat $1_ode.m3 >> $1_odeo.m

cat <<EOF >> $1_odeo.m

% The output equations
EOF
cat $1_odeo.m1 >> $1_odeo.m







