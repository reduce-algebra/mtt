#! /bin/sh

sys=$1

out=${sys}_gnuplot.wish
tmp=${sys}_gnuplot.tmp

struc=${sys}_struc.txt
dat2=${sys}_odes.dat2

Nx=`mtt_getsize ${sys} x`
Ny=`mtt_getsize ${sys} y`


## write header
cat <<EOF > ${out}
#!/bin/sh
# Next line replaces shell with wish\\
exec wish "\$0" "\$@"

## main window
wm title . "MTT Viewer: ${sys}"

set parameter ""
button .print -text "Print" -command { 
    global parameter;
    if {"\$parameter"==""} {
	tk_dialog ".mtt_Print_Error" "Print Error" "Select a parameter!" "" "0" "Try Again"
    } else {
	print \$parameter
    }
}
button .quit  -text "Quit"  -command exit

## states canvas
canvas		.cx
listbox		.cx.l
scrollbar	.cx.sy	-orient v
checkbutton    	.cx.t	-text		"States"

## outputs canvas
canvas		.cy
listbox		.cy.l
scrollbar	.cy.sy	-orient v
checkbutton    	.cy.t	-text		"Outputs"

## configure scrollbars
.cx.sy configure -command ".cx.l yview"
.cy.sy configure -command ".cy.l yview"
.cx.l configure -yscrollcommand ".cx.sy set"
.cy.l configure -yscrollcommand ".cy.sy set"

## bind lists
bind .cx.l <<ListboxSelect>> { set parameter [ .cx.l get anchor ] ; plot \$parameter }
bind .cy.l <<ListboxSelect>> { set parameter [ .cy.l get anchor ] ; plot \$parameter }

proc "reverse_name" "name" {
    set delim "_"
    set split_name [split \$name \$delim]
    set reversed_name [lindex \$split_name 0]
    for {set i 1} {\$i<[llength \$split_name]} {incr i} {
        set reversed_name [lindex \$split_name \$i]\$delim\$reversed_name
    }
    return \$reversed_name
}

proc "reverse_sort" "list" {
    set temp_list {}
    set delim " "
    foreach name [split \$list \$delim] {
	set temp_list \$temp_list\$delim[reverse_name \$name]
    }
    set temp_list [lsort -ascii \$temp_list]
    set list {}
    foreach name [split \$temp_list \$delim] {
	set list \$list\$delim[reverse_name \$name]
    }
    return \$list
}

proc "sort_list" "list sortorder" {
    if ("\$sortorder"=="normal") {
	return [lsort -ascii \$list]
    }
    if ("\$sortorder"=="reverse") {
	return [reverse_sort \$list]
    }
}

EOF

## create states and outputs lists
gawk '
($1 == "state") {
    printf "lappend xl state:%s\n", $4
}
($1 == "output") {
    printf "lappend yl output:%s\n", $4
}' ${struc} >> ${out}

cat <<EOF >> ${out}
.cx.l configure -listvar xl
.cy.l configure -listvar yl

.cx.t configure -command { set xl [sort_list \$xl \$xsortorder] } -indicatoron false -onvalue "reverse" -offvalue "normal" -variable xsortorder
.cy.t configure -command { set yl [sort_list \$yl \$ysortorder] } -indicatoron false -onvalue "reverse" -offvalue "normal" -variable ysortorder

pack .cx.t -expand false -fill x -side top
pack .cy.t -expand false -fill x -side top

pack .cx.sy -expand false -fill y -side right
pack .cy.sy -expand false -fill y -side right

pack .cx.l -expand true -fill both -side left
pack .cy.l -expand true -fill both -side left

pack .cx -expand true -fill both
place .cy -in .cx -relx 0 -rely 0 -relwidth 1 -relheight 1 -anchor nw -bordermode outside

radiobutton .states  -text "States"      -value states  -variable view      -relief solid -command { raise .cx }
radiobutton .outputs -text "Outputs"     -value outputs -variable view      -relief solid -command { raise .cy }

#menubutton .plottype -text "Plot type" -menu .plottype.plottype

#menu .plottype.plottype
tk_optionMenu .plottype plottype "Single Plot"\
                                 "Multi Plot "\
                                 "New Window "

pack .states .outputs -side left

pack .quit   -expand false -fill x -side right
pack .print  -expand false -fill x -side right
pack .plottype   -expand false -fill x -side top

## map names to column numbers
EOF

gawk '
BEGIN {
    print "proc \"plot\" \"title\" {";
}
($1 == "state") {
    printf "if (\"%s\"==\"state:%s\") { plot_var \"%s\" %d }\n", Title, $4, $4, $2+2+Ny;
}
($1 == "output") {
    printf "if (\"%s\"==\"output:%s\") { plot_var \"%s\" %d }\n", Title, $4, $4, $2+1;
}    
END {
    print  "}"
}
' Title=\$title Ny=${Ny} ${struc} >> ${out}


cat <<EOF >> ${out}

## call gnuplot
proc "plot_var" "title column" {
    puts "set grid"
    puts "set term X11"
    global plottype
    if {"\$plottype" == "Multi Plot "} {
	puts "replot '${dat2}' using 1:\$column title '\$title' with lines"
    } elseif {"\$plottype" == "New Window "} {
	puts "! echo \"plot '${dat2}' using 1:\$column title '\$title' with lines\" | gnuplot -geometry 400x300 -persist"
    } else {
	puts "plot '${dat2}' using 1:\$column title '\$title' with lines"
    }
}

## print output
proc "print" "parameter" {
    set filename [tk_getSaveFile\
	-initialdir ".."\
	-initialfile "\$parameter.ps"\
	-defaultextension ".ps"\
	-filetypes {
	    {{Postscript} {.ps}}
	    {{All files} {*}}
	}
    ]
    if {\$filename != ""} {
	puts "set term postscript"
	puts "set output \"\$filename\""
	puts "replot"
	tk_dialog ".printed" "Graph Printed!" "PostScript saved as \$filename" "" "0" "Close"
    }
}

EOF
chmod +x ${out}
